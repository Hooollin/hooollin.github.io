<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="Coder">
<meta property="og:type" content="website">
<meta property="og:title" content="Hollin的代码之路">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hollin的代码之路">
<meta property="og:description" content="Coder">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hollin">
<meta property="article:tag" content="Focus">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Hollin的代码之路</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hollin的代码之路</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hollin</p>
  <div class="site-description" itemprop="description">Coder</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Hooollin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hooollin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hollinisme@gmail.com" title="E-Mail → mailto:hollinisme@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Hooollin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/26/daily-learning/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/26/daily-learning/memcpy%E4%B8%8Ememmove%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">memcpy与memmove的区别和C语言中指针的一些技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-26 00:23:42" itemprop="dateCreated datePublished" datetime="2020-02-26T00:23:42+08:00">2020-02-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">日常学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="memcpy和memmove"><a href="#memcpy和memmove" class="headerlink" title="memcpy和memmove"></a>memcpy和memmove</h2><p>在学习string.h标准库的时候注意到了两个功能十分类似的函数：memcpy和memmove。两个函数的十分相似：</p>
<blockquote>
<p>memcpy: copies one buffer to another</p>
</blockquote>
<blockquote>
<p>memmove: moves one buffer to another</p>
</blockquote>
<p>常理来说同一个库下是不会重复实现同一个功能的，这就显得有些蹊跷。百度一下后，发现memcpy是无法保证内存重叠的情况下能正确复制，而memmove则保证复制的准确性。画个图理解一下：<br><img src="http://hollin.icu/2020-02-26_005035.png" alt="内存重叠且出错的情况"><br>可以看到，在这种情况下，本该位于6、7的d、e成了c、a。这也许和我们预想的结果不太相同（也没准有的人就是想要这种效果）。当然还有dest小于src的情况也可能产生内存重叠，但是这种内存重叠相当于把字符往前移动，不会出现意料之外的错误。<br>所以在string.h的中还有个memmove来弥补这一不足，memmove可以保证在内存重叠的情况下仍可以获得得正确的结果。那么memmove的实现实际上是单独向后移且内存重叠的情况拎出来实现，保证了结果的正确性。这里给出我自己的一种实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void *memmove(void *dest, const void *src, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    if (src &gt;&#x3D; dest || (char *)src + n &lt; (char *)dest)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t i &#x3D; 0;</span><br><span class="line">        const char *prt1 &#x3D; src;</span><br><span class="line">        char *prt2 &#x3D; dest;</span><br><span class="line">        for (; i &lt; n; i++, prt1++, prt2++)</span><br><span class="line">        &#123;</span><br><span class="line">            *prt2 &#x3D; *prt1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        char *l &#x3D; (char *)src + n;</span><br><span class="line">        size_t len &#x3D; ((char *)dest - (char *)src);</span><br><span class="line">        while (l !&#x3D; (char *)src - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            *(l + len) &#x3D; *l;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这些强制类型转换并不是必须的，但是vscode会报错，因此我还是将它们保留了。这是第二个话题将要谈到的问题。<br>当然自己的虽然实现了memmove的功能，我们也必须亲手去验证一下结论的正确性。是不是memcpy真的就没有保证内存重叠时的复制正确性呢？在Linux下我编写了如下的测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">        char str[10] &#x3D; &#123;&quot;abcdef&quot;&#125;;</span><br><span class="line">        memcpy(str + 3, str, 5);</span><br><span class="line">        printf(&quot;%s&quot;, str);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译过后的输出结果却并不如我所想的那样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;a.out</span><br><span class="line">abcabcde% </span><br></pre></td></tr></table></figure>
<p>按照之前的分析这里的结果应该是<code>abcabcab</code>，然而运行的结果确实和memmove的结果一模一样。是大多数人都错了吗？我当时这么想来着，去更靠谱的网站查询了相关资料，发现原来是这样的：<br><img src="http://hollin.icu/2020-02-26_010743.png" alt="memcpy文档">  </p>
<blockquote>
<p>If the objects overlap (which is a violation of the restrict contract) (since C99), the behavior is undefined. The behavior is undefined if either dest or src is a null pointer.</p>
</blockquote>
<p>这里提到了当发生内存重叠的时候，它并没有一个标准的实现。也就是说，不同的平台下可能会有不同的实现方式。可能Linux下它的实现与memmove是一样的。<br>我自己也实现了一下memcpy，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *dest, const void *src, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">    const char *prt1 &#x3D; src;</span><br><span class="line">    char *prt2 &#x3D; dest;</span><br><span class="line">    size_t i &#x3D; 0;</span><br><span class="line">    for (; i &lt; n; i++, prt1++, prt2++)</span><br><span class="line">    &#123;</span><br><span class="line">        *prt2 &#x3D; *prt1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/Hooollin/re-examination/blob/master/algorithm/_string.c">我实现的string.h中的一些函数</a>  </p>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li>显然memcpy的速度会比memmove快一些, memmove要稳一点。</li>
<li>不想因为跨平台的而出问题最好用memmove。</li>
</ul>
<h2 id="指针运算以及一些技巧"><a href="#指针运算以及一些技巧" class="headerlink" title="指针运算以及一些技巧"></a>指针运算以及一些技巧</h2><h3 id="指针的大小"><a href="#指针的大小" class="headerlink" title="指针的大小"></a>指针的大小</h3><p>指针的大小取决于三个方面：</p>
<ul>
<li>CPU的位数</li>
<li>操作系统位数</li>
<li>编译器的位数</li>
</ul>
<p>指针的大小受限于三者中最小那个，在32位操作系统中一般为4个字节，在64位操作系统中一般为8个字节。不论是int<em>、char</em>、还是void*的大小都是一样的。</p>
<h3 id="int、char、void-的具体含义"><a href="#int、char、void-的具体含义" class="headerlink" title="int、char、void*的具体含义"></a>int<em>、char</em>、void*的具体含义</h3><p>比如说对于这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 0;char b &#x3D; &#39;0&#39;;float c &#x3D; 0.0;</span><br><span class="line">    int *p1 &#x3D; &amp;a;char *p2 &#x3D; &amp;b; char *p3 &#x3D; &amp;c, void* p4 &#x3D; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>int*</code>代表了p1指向的是一个int类型的数据，那么你通过<code>*p1</code>访问a，无论p1指向的数据类型是不是a它都会将内存中的数据按照int来解释。<br>void*则代表当前的数据类型不确定，如果需要解应用必须强制类型转换，否则将会报错。但是任何类型的指针都可以复制给void *类型的指针。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>最简单的指针运算无非是加一，减一，关键就是不同类型下它的计算方式稍有不同。</p>
<ul>
<li>int *p，p++使得p指向的地址在原来的基础上移动了int类型字节数。</li>
<li>float *p，p++使得p指向的地址在原来的基础上增加了float类型的字节数。</li>
<li>char *p，p++使得p指向的地址在原来的基础上增加了char类型的字节数。</li>
<li>void *p，默认和char *一样。</li>
</ul>
<p>两个不同的指针之间的运算：</p>
<ul>
<li>前提是两个指针同类型。</li>
<li>同类型指针之间的加减的结果是已经除过sizeof的了，也就是说结果不是间隔的字节数。</li>
<li>可以直接比大小。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/23/daily-learning/%E9%93%BE%E8%A1%A8%E4%B8%ADswap%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/23/daily-learning/%E9%93%BE%E8%A1%A8%E4%B8%ADswap%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9/" class="post-title-link" itemprop="url">链表中swap两个结点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-23 22:58:43" itemprop="dateCreated datePublished" datetime="2020-02-23T22:58:43+08:00">2020-02-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">日常学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>一开始想直接动手写链表的bubble sort，结果代码没写两行就卡壳了。在geeksforgeeks里面找了一下没有找到，不过却发现了swap两个结点的Puzzle，当实心里想这太基础了，不过刷了一眼分析发现问题可能比我想像中的要复杂一些，于是便想自己试一试能不能写出来。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>首先要想swap两个结点，是不是只需要分别记录一下prev结点和curr结点然后改一下指向就能解决的呢？一开始我是这么想的，于是写出了以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void swap(LinkedList *head, ListNode *node1, ListNode *node2)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode *prev1 &#x3D; head, *curr1 &#x3D; head-&gt;next, *prev2 &#x3D; head, *curr2 &#x3D; head-&gt;next, *next;</span><br><span class="line">    for (; curr1 !&#x3D; node1; prev1 &#x3D; prev1-&gt;next, curr1 &#x3D; curr1-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    for (; curr2 !&#x3D; node2; prev2 &#x3D; prev2-&gt;next, curr2 &#x3D; curr2-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    next &#x3D; curr1-&gt;next;</span><br><span class="line">    curr1-&gt;next &#x3D; curr2-&gt;next;</span><br><span class="line">    curr2-&gt;next &#x3D; next;</span><br><span class="line">    prev1-&gt;next &#x3D; curr2;</span><br><span class="line">    prev2-&gt;next &#x3D; curr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码结构很清晰，前两个循环用来定位，后面五行用来互换两个结点。乍一看好像挺对的，没什么问题。不过思考一下这种情况：<br><img src="http://hollin.icu/2020-02-23_231716.png" alt="过程图"><br>当node1和node2相邻的时候，会造成不止一个环路。<br>看来结点的位置关系会影响最后的结果，因此需要搞清楚这两个结点之间的关系：</p>
<ul>
<li>有没有结点是头结点？</li>
<li>两个结点是否相邻？</li>
</ul>
<p>对于带头结点的链表我们不需要考虑是否其中一个为头结点，因为头结点的一个作用就是统一的操作的过程。<br>如果两个结点相邻，必然导致会有多余的指针，我们的代码中需要对它进行处理。不相邻的话初始版本的代码是正确的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>基于以上分析给出swap两个结点的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void swap(LinkedList *head, ListNode *node1, ListNode *node2)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode *prev1 &#x3D; head, *curr1 &#x3D; head-&gt;next, *prev2 &#x3D; head, *curr2 &#x3D; head-&gt;next, *next;</span><br><span class="line">    for (; curr1 !&#x3D; node1; prev1 &#x3D; prev1-&gt;next, curr1 &#x3D; curr1-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    for (; curr2 !&#x3D; node2; prev2 &#x3D; prev2-&gt;next, curr2 &#x3D; curr2-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    if (curr1-&gt;next &#x3D;&#x3D; curr2)</span><br><span class="line">    &#123;</span><br><span class="line">        next &#x3D; curr2-&gt;next;</span><br><span class="line">        curr2-&gt;next &#x3D; curr1;</span><br><span class="line">        curr1-&gt;next &#x3D; next;</span><br><span class="line">        prev1-&gt;next &#x3D; curr2;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (curr2-&gt;next &#x3D;&#x3D; curr1)</span><br><span class="line">    &#123;</span><br><span class="line">        next &#x3D; curr1-&gt;next;</span><br><span class="line">        curr1-&gt;next &#x3D; curr2;</span><br><span class="line">        curr2-&gt;next &#x3D; next;</span><br><span class="line">        prev2-&gt;next &#x3D; curr1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        next &#x3D; curr1-&gt;next;</span><br><span class="line">        curr1-&gt;next &#x3D; curr2-&gt;next;</span><br><span class="line">        curr2-&gt;next &#x3D; next;</span><br><span class="line">        prev1-&gt;next &#x3D; curr2;</span><br><span class="line">        prev2-&gt;next &#x3D; curr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下：<br><img src="http://hollin.icu/2020-02-23_232927.png" alt="测试结果">  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/swap-nodes-in-a-linked-list-without-swapping-data/">geeksforgeeks上的解法</a></li>
<li>多动手。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/22/daily-learning/%E7%94%A8%E5%BF%AB%E6%8E%92%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%B0%8F-%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/22/daily-learning/%E7%94%A8%E5%BF%AB%E6%8E%92%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%B0%8F-%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">用快排找数组中第k小/大的元素的两种实现方式或最小k个数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-22 17:23:03" itemprop="dateCreated datePublished" datetime="2020-02-22T17:23:03+08:00">2020-02-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">日常学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先最简单的思路就是先排序然后直接返回下标为k的元素，这样能达到$O(nlogn)$的时间复杂度。既然想要利用排序来查找，那么可以借助快排每趟确定一个元素的位置，并且在这个元素左边的数均小于它，右边的数均大于它的性质来把这个查找的时间复杂度降低为$O(n)$。  </p>
<h2 id="快排代码"><a href="#快排代码" class="headerlink" title="快排代码"></a>快排代码</h2><p>那么目前第一件事就是把快排的代码迅速写出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void qsort(int *arr, int lo, int hi, int k)&#123;</span><br><span class="line">     if (lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; _lo和_hi保存他们的初始值</span><br><span class="line">        int _lo &#x3D; lo, _hi &#x3D; hi;</span><br><span class="line">        &#x2F;&#x2F; partition的过程</span><br><span class="line">        int key &#x3D; arr[lo];</span><br><span class="line">        while (lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            while (lo &lt; hi &amp;&amp; arr[hi] &gt;&#x3D; key)</span><br><span class="line">            &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[lo] &#x3D; arr[hi];</span><br><span class="line">            while (lo &lt; hi &amp;&amp; arr[lo] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[hi] &#x3D; arr[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] &#x3D; key;</span><br><span class="line">        &#x2F;&#x2F;递归左边和右边</span><br><span class="line">        qsort(arr, _lo, lo - 1, k);</span><br><span class="line">        qsort(arr, lo + 1, _hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h2><p>当我们partition结束时，$lo=hi$且都指向了已经在正确位置上的那个初始的pivot。此时$lo=hi$与$k$之间的关系有三种情况：</p>
<ol>
<li>很显然，当$lo=hi=k-1$的时候，也就意味着我们已经找到了这个第k大的元素。此时直接返回就可以了。</li>
<li>当$lo=hi&gt;k-1$时，说明第k大的元素在pivot的左边，此时我们需要递归左边的数组。</li>
<li>当$lo=hi&lt;k-1$时，说明第k大的元素在pivot的右边，此时我们需要递归右边的数组。</li>
</ol>
<p>有如上分析，修改代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int kthElement(int *arr, int lo, int hi, int k)</span><br><span class="line">&#123;</span><br><span class="line">    if (lo &lt;&#x3D; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        int _lo &#x3D; lo, _hi &#x3D; hi;</span><br><span class="line">        int key &#x3D; arr[lo];</span><br><span class="line">        while (lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            while (lo &lt; hi &amp;&amp; arr[hi] &gt;&#x3D; key)</span><br><span class="line">            &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[lo] &#x3D; arr[hi];</span><br><span class="line">            while (lo &lt; hi &amp;&amp; arr[lo] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[hi] &#x3D; arr[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] &#x3D; key;</span><br><span class="line">        if (lo &#x3D;&#x3D; k - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (lo &gt; k - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return kthElement(arr, _lo, lo - 1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        return kthElement(arr, lo + 1, _hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路没有问题。然而最后还需要考虑一下第三行里面的判断条件：<code>lo &lt; hi</code>，当lo=hi且恰好为目标元素时，将会导致结果错误。因此修改为<code>lo &lt;= hi</code>。程序正常运行（搞了很久）。</p>
<h2 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int _kthElement(int *arr, int lo, int hi, int k)</span><br><span class="line">&#123;</span><br><span class="line">    while (lo &lt;&#x3D; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        int _lo &#x3D; lo, _hi &#x3D; hi;</span><br><span class="line">        int key &#x3D; arr[lo];</span><br><span class="line">        while (lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            while (lo &lt; hi &amp;&amp; arr[hi] &gt;&#x3D; key)</span><br><span class="line">            &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[lo] &#x3D; arr[hi];</span><br><span class="line">            while (lo &lt; hi &amp;&amp; arr[lo] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[hi] &#x3D; arr[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] &#x3D; key;</span><br><span class="line">        if (lo &#x3D;&#x3D; k - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (lo &gt; k - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            hi &#x3D; lo - 1;</span><br><span class="line">            lo &#x3D; _lo;</span><br><span class="line">        &#125;</span><br><span class="line">        lo &#x3D; lo + 1;</span><br><span class="line">        hi &#x3D; _hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更优秀的代码"><a href="#更优秀的代码" class="headerlink" title="更优秀的代码"></a>更优秀的代码</h2><p>快排在如果能够做将数组均匀分成左右两个部分的话性能将达到真正意义上的$O(nlogn)$，可惜做不到。不过我们还是可以采取一些措施使得尽量避免最坏情况的产生，就比如说随机选取pivot。<br>在<code>nums[n] = &#123;n-1, n-2, n-3, ···,1, 0&#125;</code>的情况下，选择最左边的元素作为pivot将会导致快排的时间复杂度为$O(n^2)$。<br>如果我我们随机选取pivot，那将只有$1/n$的概率选取的pivot为最坏情况，而最坏情况出现的概率为$1/n!$，这样看我们碰到并且选取到最坏pivot的概率只有$1/n * 1/n!$。简单分析后写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int findKthLargest(int *nums, int numsSize, int k)</span><br><span class="line">&#123;</span><br><span class="line">    srand(time(0));</span><br><span class="line">    int lo &#x3D; 0, hi &#x3D; numsSize - 1;</span><br><span class="line">    k &#x3D; numsSize - k;</span><br><span class="line">    while (lo &lt;&#x3D; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        int i &#x3D; lo, j &#x3D; hi;</span><br><span class="line">        int pi &#x3D; randint(i, j);</span><br><span class="line">        if (pi !&#x3D; i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums, pi, i);</span><br><span class="line">        &#125;</span><br><span class="line">        int key &#x3D; nums[i];</span><br><span class="line">        while (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            while (i &lt; j &amp;&amp; nums[j] &gt;&#x3D; key)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] &#x3D; nums[j];</span><br><span class="line">            while (i &lt; j &amp;&amp; nums[i] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] &#x3D; key;</span><br><span class="line">        if (i &#x3D;&#x3D; k)</span><br><span class="line">        &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (i &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            hi &#x3D; i - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            lo &#x3D; i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小k个数"><a href="#最小k个数" class="headerlink" title="最小k个数"></a>最小k个数</h2><blockquote>
<p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int getRandomPivot(int lo, int hi)&#123;</span><br><span class="line">    return rand() %(hi - lo) + lo;</span><br><span class="line">&#125;</span><br><span class="line">int partition(int *arr, int lo, int hi)&#123;</span><br><span class="line">    int k_pos &#x3D; getRandomPivot(lo, hi);</span><br><span class="line">    int t &#x3D; arr[k_pos];</span><br><span class="line">    arr[k_pos] &#x3D; arr[lo];</span><br><span class="line">    arr[lo] &#x3D; t;</span><br><span class="line">    int key &#x3D; arr[lo];</span><br><span class="line">    while(lo &lt; hi)&#123;</span><br><span class="line">        while(lo &lt; hi &amp;&amp; arr[hi] &gt;&#x3D; key)&#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] &#x3D; arr[hi];</span><br><span class="line">        while(lo &lt; hi &amp;&amp; arr[lo ] &lt; key)&#123;</span><br><span class="line">            lo ++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[hi] &#x3D; arr[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[lo] &#x3D; key;</span><br><span class="line">    return lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void q_sort(int *arr, int lo, int hi, int k)&#123;</span><br><span class="line">    if(lo &lt; hi)&#123;</span><br><span class="line">        int pos &#x3D; partition(arr, lo, hi);</span><br><span class="line">        if(pos &#x3D;&#x3D; k)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pos &gt; k)&#123;</span><br><span class="line">            q_sort(arr, lo, pos - 1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        else   q_sort(arr, pos + 1, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int* smallestK(int* arr, int arrSize, int k, int* returnSize)&#123;</span><br><span class="line">    srand(time(0));</span><br><span class="line">    *returnSize &#x3D; k;</span><br><span class="line">    int *res &#x3D; (int*) malloc(sizeof(int) * k);</span><br><span class="line">    q_sort(arr, 0, arrSize - 1, k - 1);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; k; i++)&#123;</span><br><span class="line">        res[i] &#x3D; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把堆的代码也搞熟练吧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/21/daily-learning/%E4%BD%BF%E7%94%A8objdump%E6%BA%90%E4%BB%A3%E7%A0%81%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/21/daily-learning/%E4%BD%BF%E7%94%A8objdump%E6%BA%90%E4%BB%A3%E7%A0%81%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">使用objdump源代码查看汇编代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-21 16:44:55" itemprop="dateCreated datePublished" datetime="2020-02-21T16:44:55+08:00">2020-02-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">日常学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过VS2016可以在调试的过程中查看源代码以及对应的汇编代码，然而受限于内存，用一个编辑器打开汇编代码显然更香。步骤：</p>
<ul>
<li>通过gcc编译源代码时，加上-g的选项使得objdump可以实现源代码和汇编代码的对照，同时需要-c生成目标文件。<img src="http://hollin.icu/gcc_command.png" alt="命令行">  </li>
<li>接下来直接objdump -S filename就可以查看C语句对应的汇编语言代码了。<img src="http://hollin.icu/objdump_command.png" alt="命令行">  </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/16/daily-learning/Hexo%E4%B8%8BGithubPages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/16/daily-learning/Hexo%E4%B8%8BGithubPages%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84%E5%9D%91/" class="post-title-link" itemprop="url">Hexo下GithubPages配置自定义域名需要注意的点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-16 15:23:03" itemprop="dateCreated datePublished" datetime="2020-02-16T15:23:03+08:00">2020-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天想把一个二级域名绑定到GithubPages，正确解析以及配置完custom domain过后，只要一重新Deployment，本来可以通过二级域名访问的GithubPages无法正常访问。<br><img src="http://hollin.icu/hexo-bug-1.png" alt="hexo-bug-1"><br><img src="http://hollin.icu/hexo-bug-3.png" alt="hexo-bug-2"><br>前前后后摸索了一会发现每次配置custom domain过后github都会在这个仓库里面新增一个CNAME文件用来指示绑定的域名。最后在Hexo下source文件夹中新建了一个CNAME成功解决了这个问题。<br><img src="http://hollin.icu/hexo-bug-2.png" alt="hexo-bug-3"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/16/computer-networking/computer-networking-chapter5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/16/computer-networking/computer-networking-chapter5/" class="post-title-link" itemprop="url">计算机网络第五章学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-16 13:17:09" itemprop="dateCreated datePublished" datetime="2020-02-16T13:17:09+08:00">2020-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链路层：链路、接入网和局域网"><a href="#链路层：链路、接入网和局域网" class="headerlink" title="链路层：链路、接入网和局域网"></a>链路层：链路、接入网和局域网</h1><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><p>运行链路层任何协议的设备都称为<strong>结点（node）</strong>。结点包括主机、路由器、交换机和WIFI接入点。<br>网络层和链路层的关系：<br><img src="http://hollin.icu/CN-5-metaphor.png" alt="5-1metaphor">  </p>
<h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p>任一链路层的<strong>基本服务</strong>都是将数据报通过单一通信链路从一个结点移动到相邻结点。链路层协议能提供的可能服务包括：</p>
<ul>
<li><strong>成帧（framing）</strong>。每个网络层的数据报经链路层传送之前，都需要将链路层帧封装起来。</li>
<li>链路接入。<strong>媒体访问控制（Medium Access Control，MAC）</strong>协议规定了帧在链路上的传输规则。</li>
<li>可靠交付。无线链路中易于产生高差错率，而光纤等其他差错率不高的链路中可靠交付被认为是没有必要的开销。</li>
<li>差错检测和纠正。</li>
</ul>
<h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>链路链路层的主体部分是在<strong>网络适配器（network adapter）</strong>中实现的，有时也被称为<strong>网络接口卡（Network Interface Card，NIC）</strong>。<br>位于网络适配器核心的是链路层控制器，它通常是实现了许多链路层服务的专用芯片，如：成帧、链路接入、差错检测等。很早之前的网络适配器还只是物理上分离的卡，现在越来越多的网络适配器被综合进了主机的主板，即所谓的局域网在主板配置。<br><img src="http://hollin.icu/CN-5-2.png" alt="CN-5-2网络适配器">  </p>
<h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><p><strong>比特级的差错检测和纠正（bit-level error detection and correction）</strong>：从一个结点到另一个结点的帧中的比特损伤进行检测和纠正。<br>在发送结点，为了保护比特免受差错适用了<strong>差错检测和纠正比特（Error-Detection and-Correction，EDC）</strong>来增强数据D。在接收方的D’和EDC’可能与初始的D和EDC不同。<br><img src="http://hollin.icu/CN-5-3.png" alt="CN-5-3差错检测和纠正的场景"><br>那么接收方面临的挑战就是如何通过D’和EDC’来判断是否出现差错。不过即使使用差错检验比特，也有可能出现<strong>未检出比特差错（undetected bit error）</strong>。一般而言，越是复杂的纠错技术，开销也就越大，检测效果越好。<br>现在有三种常见的差错检测的技术：</p>
<ul>
<li>奇偶校验。</li>
<li>检验和方法。</li>
<li>循环冗余检测。</li>
</ul>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>使用单个<strong>奇偶校验位（parity bit）</strong>。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这$d+1$个比特中1的总数是偶数。在这种情况下，出现了奇数个比特差错将会被接收方检测出来。如果出现比特差错的概率比较小，那么在一个分组下多个比特同时出错的概率极小。  </p>
<p>单比特奇偶校验方案的二维化一般方案可以不仅检错，甚至纠错。<br><img src="http://hollin.icu/CN-5-5.png" alt="5-5二维校验"><br>接收方检测和纠正差错的能力被称为<strong>向前纠错（Forward Error Correction，FEC）</strong>。</p>
<h3 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h3><p><strong>因特检检验和</strong>就是基于这种方法。每16位求和，溢出回卷，最后取反放到检验和字段。</p>
<h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><p>计算机网络中广泛应用的差错检测技术基于<strong>循环冗余检测（Cyclic Redundancy Check，CRC）编码</strong>。  </p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>有两种类型的网络链路：</p>
<ul>
<li><strong>点对点链路（point-to-point link）</strong>由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如<strong>点对点协议（point-to-point protocol，PPP）</strong>和<strong>高级数据链路控制（high-level data link control，HDLC）</strong>。</li>
<li>第二种类型的链路是<strong>广播链路（broadcast link）</strong>，它能让多个发送和接收方都连接到相同的、单一的、共享的广播信道上。以太网和无线网都是广播链路层技术的例子。  </li>
</ul>
<p>如何协调多个发送和接收结点对一个共享广播信道的访问，这就是<strong>多路访问问题（multiple access problem）</strong>。<br>计算估计网络中为了共享广播信道而设计得到的协议称为<strong>多路访问协议（multiple access protocol）</strong>，即各个结点通过这些协议来规范他们在共享的广播信道上的传输行为。从技术上讲每个结点通过它的适配器访问广播信道。<br><img src="http://hollin.icu/CN-5-8.png" alt="CN-5-8">  </p>
<p>因为所有的结点都可以传输帧，所以多个结点可能同时传输帧。所有的结点都可以接收帧，所以多个结点可能同时接到多个帧。传输的帧在所有的接收方处<strong>碰撞（collide）</strong>了。那么当帧碰撞到一起，这段时间间隔内的广播信道被浪费了。<br>当多个结点处于活跃状态时，需要以某种方式协调活跃结点的传输时必要的。<strong>这种工作由多路访问协议负责</strong>。  </p>
<p>多路访问协议可以划分为三种类型：</p>
<ul>
<li>信道划分协议（channel partitioning protocol）。</li>
<li>随机接入协议（random access protocol）。</li>
<li>轮流协议（taking-turns protocol）。</li>
</ul>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p><strong>时分多路复用（TDM）</strong>和<strong>频分多路复用（FDM）</strong>是两种能有用于在所有共享信道结点之间划分广播信道带宽的技术。<br>TDM将时间划分为<strong>时间帧（time frame）</strong>，并把每个时间帧划分为$N$个<strong>时隙（slot）</strong>。将每个时隙分给N个结点中的一个。通常时隙的长度应该足够传输单个分组。<br><img src="http://hollin.icu/CN-5-9.png" alt="CN-5-9"><br>TDM中每个结点在每个帧的时间内得到了专用的传输速度$R/Nbps$，但是它有两个主要缺陷：</p>
<ul>
<li>结点的传输速率被限制，即使它是唯一一个要发送分组的结点。</li>
<li>当所有的结点都想收到来自一个结点的分组时效率很低。</li>
</ul>
<p>FDM将Rbps的信道划分为不同的频段，和TDM一样，它也有限制带宽的缺点。<br>第三种信道划分协议是<strong>码分多址（Code Division Multiple Access，CDMA）</strong>。在码分多址中，每个结点都有一种不同的编码，并且在接收方可以解码来自不同的发送方的编码。</p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>随机接入协议中传输结点总时以信道的全部速率进行发送。当有碰撞时候，每个碰撞的结点反复重发它的帧，直到该帧无碰撞通过为止。</p>
<h4 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h4><h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><h4 id="载波侦听多路访问（CSMA）"><a href="#载波侦听多路访问（CSMA）" class="headerlink" title="载波侦听多路访问（CSMA）"></a>载波侦听多路访问（CSMA）</h4><p>重要规则：</p>
<ul>
<li>说话之前先听。这在网络领域被称为<strong>载波侦听（carrier sensing）</strong>。没有检测到其他正在传输的结点后开始传输。</li>
<li>如果如他人同时开始说话，停止说话。这在网络领域被称为<strong>碰撞检测（collision detection）</strong>。检测到了碰撞停止传输并随机等待一段时间。</li>
</ul>
<p>这两个规则包含在<strong>载波侦听多路访问（Carrier Sense Multiple Access，CSMA）</strong>和<strong>具有碰检测的CSMA（CSMA with Collision Dectection， CSMA/CD）</strong>协议族中。<br><img src="http://hollin.icu/CN-5-12.png" alt="CN-5-12">  </p>
<h4 id="具有碰撞检测的载波侦听多路访问（CSMA-CD）"><a href="#具有碰撞检测的载波侦听多路访问（CSMA-CD）" class="headerlink" title="具有碰撞检测的载波侦听多路访问（CSMA/CD）"></a>具有碰撞检测的载波侦听多路访问（CSMA/CD）</h4><p>在载波侦听多路访问的基础上增加了碰撞检测，一旦发生碰撞检测将立即停止传输。<br>它的运行过程从广播信道的角度上来看是这样的：</p>
<ol>
<li>适配器从网络层获得胡举报，准备链路层帧，并放入帧适配器缓存中。</li>
<li>如果适配器侦听到信道空闲（无能量信号从信道进入适配器）就开始传输帧。如果侦听到信道正在忙，就等待直到没有信号能量才开始传输。</li>
<li>在传输的过程中继续监视信道是否有能量信号。</li>
<li>如果适配器在传输的整个过程中都没有检测到来自其他适配器的信号能量，那么该帧就传送完成。否则中止传送。</li>
<li>中止传输后，适配器随机等待一段时间，并返回步骤2。</li>
</ol>
<p>这个随机等待的时间选取应该遵循碰撞节点数量较少时，时间间隔较短；碰撞节点数量较大时，时间间隔较长。  </p>
<p>用于以太网以及DOCSIS电缆网络多路访问协议中的<strong>二进制后退（binary exponential backoff</strong>）算法解决了随即等待时间长度的问题。<br><img src="http://hollin.icu/CN-5-sample-1.png" alt="CN-5-sample-1">  </p>
<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p>轮流协议有很多种，其中有两种比较重要，分别是：</p>
<ul>
<li><strong>轮询协议（polling protocol）</strong>。在一个网络拓扑中需要指定一个主结点用以轮询其余结点。每个结点在它的轮次可以向主节点发送固定数量的帧，然后到下一个结点。缺点：主结点崩了整个网络就崩了；轮询时延。</li>
<li><strong>令牌传递协议（token-passing protocol）</strong>：这种协议下的结点都有一个称为令牌的特殊帧以某种固定的次序进行交换。比如说结点1可能总是把令牌发给结点2，结点2总是把令牌发给结点3，以此类推。缺点：一个结点故障会导致整个信道崩溃。</li>
</ul>
<h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><p><img src="http://hollin.icu/CN-5-15.png" alt="CN-5-15">  </p>
<h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><p>主机和路由器具有链路层地址。</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>事实上不是主机或者路由器具有链路层地址，而是他们的适配器（网络接口）具有链路层地址。链路层地址有各种不同的称呼：</p>
<ul>
<li><strong>LAN地址（LAN address）</strong>；</li>
<li><strong>物理地址（physical address）</strong>或<strong>MAC地址（MAC address）</strong>。</li>
</ul>
<p>对于大多数局域网（包括以太网和802.11无线局域网）而言，MAC地址长度为6字节，共有$2^{48}$个可能的MAC地址。一个适配器的MAC地址不会改变。<br>当某帧的目的地址为FF-FF-FF-FF-FF时，这是一个特殊端<strong>MAC广播地址（broadcast address）</strong>。  </p>
<h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><p>因为存在网络层地址和链路层地址，所以需要在他们之间转换。对于因特网而言，这是<strong>地址解析协议（Address Resolution Protocol，ARP）</strong>。<br><img src="http://hollin.icu/CN-5-17.png" alt="CN-5-17"><br>在上面这个简单的例子中，假设IP地址为$222.222.222.220$的主机要向主机$222.222.222.222$发送IP数据报。为了发送数据报，源主机不仅要提供IP地址，还必须提供目的主机的MAC地址。<br>在这种情况下，源主机使用ARP，在发送主机的ARP模块中将取<strong>相同局域网</strong>上的任何IP地址作为输入，并且返回相应的MAC地址。<br>ARP和DNS有些类似，但是ARP只为同一个子网上的主机和路由器接口解析IP地址。否则将会返回一个错误。  </p>
<p><img src="http://hollin.icu/CN-5-18.png" alt="CN-5-18"><br>ARP的工作方式：每台主机或路由器在其内存中都有一个<strong>ARP表（ARP table）</strong>，这个表包含IP地址到MAC地址的映射关系。发送方首先构造一个<strong>ARP分组（ARP packet）</strong>，并且指示适配器应该用MAC广播地址来发送这个分组。每个适配器接收到这个ARP分组过后就将其上传到ARP模块，并且检查IP地址是否与ARP分组中的目的IP地址相匹配，如果匹配就给查询主机发送回一个响应的ARP分组。查询主机收到了ARP分组过后就更新它的ARP表，并发送它的IP数据报。  </p>
<h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><p><img src="http://hollin.icu/CN-5-19/png" alt="CN-5-19"><br>假设主机$111.111.111.111$要向主机$222.222.222.222$发送一个IP数据报。此时，发送主机需要向适配器指示一个适当的目的MAC地址。<br>显然这个适配器的地址不可能在子网中找到，那么能直接写上$222.222.222.222$的适配器地址吗？不行。如果真的这么写了，子网一根本不会有任何一个主机或者适配器理他，因为MAC地址不匹配。<br>从网络层的学习中我们可以得知，首先我们网络层分组是要往另一个网络中发送的，这个分组需要从网关路由器中发送出去。那么我们需要填的就是<strong>网关路由器的MAC地址</strong>。<br>IP数据报因此能成功传到第一跳路由器中。那么接下来的操作就比较显然了。  </p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网几乎占领着现有的有限局域网市场。以太网是到目前为止最流行有限局域网技术，并且在可以预见的未来它可能仍保持这一位置。<br>以太局域网是20世纪70年代中期发明的，初始的以太网使用同轴电缆总线来互联结点。使用总线拓扑的以太网是一种广播局域网，<strong>所有传输的帧传送到与该总线连接的所有适配器并被其处理</strong>。<br>20世纪90年代后期，大多数哦公司和大学使用一种基于集线器的星形拓扑结构替代了局域网。<strong>集线器（hub）</strong>是一种物理层设备。每当一个0或者一个1的比特到达这个接口，集线器重新生成这个比特并且向其他所有接口传输出去。<br>21世纪早期，集线器被<strong>交换机（switch）</strong>替代了。</p>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="http://hollin.icu/CN-5-20.png" alt="CN-5-20">  </p>
<ul>
<li><strong>数据字段</strong>（46~1500字节）。这个字段承载了IP数据报。以太网的最大传输单元（MTU）是1500字节，如果IP数据报超过了这个长度需要被主机切片。最小长度是46字节，如果IP数据报小于46字节，那么数据报必须被填充到46字节。</li>
<li><strong>目的地址</strong>（6字节）。目的地址是自己适配器或者说广播地址的帧都会传给网络层。如果是其他MAC地址的帧就丢弃。</li>
<li><strong>源地址</strong>（6字节）。</li>
<li><strong>类型字段</strong>（2字节）。类型字段允许以太网复用多种网络层协议。一台给定的主机能够使用除了IP以外的其他网络层协议。当以太网帧到达适配器的时候，适配器需要知道通过类型字段进行多路分解。</li>
<li>CRC（4字节）。用来检测帧是否出现了差错。</li>
<li>前同步码（8字节）。前七个字节都是$10101010$，最后一个字节是$10101011$。前七个字节用来唤醒接收适配器，并且需要将他们的时钟和发送方的时钟同步。同步的原因是因为适配器处于不同类型的以太局域网中，可能传输数据的速度不同。并且A不会以精确的额定速率精确传输帧，相对于额定速率有一个偏移。通过前七个字节，就能够锁定适配器A的时钟。并且第8个字节中的两个连续的1警告适配器B重要的内容就要来了。</li>
</ul>
<p>以太网技术都向网络层提供不可靠服务（unreliable service）。</p>
<h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机的任务是接收入链路层帧并且将他们转发到出链路。减缓子自身对子网中的路由器是<strong>透明的（transparent）</strong>。  </p>
<h4 id="交换机转发和过滤——略过了"><a href="#交换机转发和过滤——略过了" class="headerlink" title="交换机转发和过滤——略过了"></a>交换机转发和过滤——略过了</h4><p><strong>过滤（filtering）</strong>是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。<br><strong>转发（forwarding）</strong>是决定一个帧应该被导向哪个接口，并且把该帧移动到哪些接口的交换机功能。</p>
<h2 id="Web页面请求的历程"><a href="#Web页面请求的历程" class="headerlink" title="Web页面请求的历程"></a>Web页面请求的历程</h2><p>一名学生Bob将他的便携机与学校的以太网交换机相连，下载一个Web页面。如下图：<br><img src="http://hollin.icu/CN-5-32.png" alt="CN-5-32">  </p>
<h3 id="准备：DHCP、UDP、IP和以太网"><a href="#准备：DHCP、UDP、IP和以太网" class="headerlink" title="准备：DHCP、UDP、IP和以太网"></a>准备：DHCP、UDP、IP和以太网</h3><p>假设Bob的笔记本以一根以太网电缆连接到学校的以太网交换机，交换机又与路由器相连。学校的路由器与Comcast网络相连，它是学校的ISP。comcast.net为学校提供DNS服务。假设DHCP运行在路由器中。<br>当Bob与网络连接时，没有IP地址他就不能做任何事情。所以第一个网络相关的动作是运行DHCP协议，以从本地DHCP服务器获得一个IP地址以及其他信息。  </p>
<ol>
<li>Bob便携机上的操作系统生成一个DHCP请求报文，并将这个请求报文放入具有目的端口67和源端口的68的UDP报文段，UDP报文则又被放置在一个具有广播IP地址的和源地址$0.0.0.0$的IP数据报中。</li>
<li>包含DHCP请求报文的IP数据报则被放置在以太网帧中。这个以太网帧具有目的MAC地址$FF:FF:FF:FF:FF:FF$，使得该帧将广播到与交换机连接的所有设备（顺利的话也包括DHCP服务器）；源MAC地址是Bob便携机的MAC地址。</li>
<li>包含DHCP请求的广播以太网帧是第一个由Bob便携机发送到以太网交换机的帧。</li>
<li>路由器获取到了这个帧并且从下网上分解到UDP，DHCP请求报文从UDP报文段中抽取出来。</li>
<li>假设DHCP服务器能够以SIDR分配IP地址。假设分配给Bob的IP地址是$68.85.2.101$。DHCP服务器生成一个包含这个IP地址以及DNS服务器的IP地址、默认网关路由器的IP地址和网络掩码的一个DHCP ACK报文。这个报文被放入一个UDP报文段中，然后被放入一个IP数据报中，最后封装成帧。</li>
<li>帧到达交换机。交换机是自学习的，因此他可以直接将这个帧通向Bob便携机的输出端口转发。</li>
<li>Bob接收到了这个帧，最后抽取出来DHCP ACK报文。DHCP客户配置IP地址等网络相关参数。</li>
</ol>
<h3 id="仍在准备：DNS和ARP"><a href="#仍在准备：DNS和ARP" class="headerlink" title="仍在准备：DNS和ARP"></a>仍在准备：DNS和ARP</h3><p>当Bob将<a target="_blank" rel="noopener" href="http://www.google.com输入到其web浏览器中,这将导致谷歌的主页最终显示在其web浏览器上.bob的web浏览器通过生成一个tcp套接开始了该过程,并且套接字用于向www.google.com发送http请求.为了生成这个套接字,bob便携机需要知道google首页的ip地址.使用dns协议即可./">www.google.com输入到其Web浏览器中，这将导致谷歌的主页最终显示在其Web浏览器上。Bob的Web浏览器通过生成一个TCP套接开始了该过程，并且套接字用于向www.google.com发送HTTP请求。为了生成这个套接字，Bob便携机需要知道google首页的IP地址。使用DNS协议即可。</a><br>8. Bob便携机上的操作系统因此生成一个DNS查询报文，这个报文被防止到一个目的端口为53的UDP报文中。<br>9. Bob便携机则将包含DNS请求报文的数据报放入一个以太网帧中。该帧在链路层寻址找到网关路由器。通过第五步我们知道了网关路由器的IP地址，然而还并不知道这个路由器的MAC地址。因此接下来需要使用ARP协议。<br>10. Bob的笔记本生成一个具有目的IP地址68.85.2.1（默认网关）的ARP查询报文，并将这个报文放置在一个具有广播地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器。<br>11. 网关路由器接收到了包含该ARP查询报文的帧，因此准备一个ARP回答，指示他的MAC地址。<br>12. Bob的笔记本接收到了ARP回答报文的帧，并且抽取出网关路由器的MAC地址。<br>13. Bob重与可以发送包含DNS查询的以太网帧寻址到网关路由器的MAC地址。</p>
<h3 id="仍在准备：域内路由选择到DNS服务器"><a href="#仍在准备：域内路由选择到DNS服务器" class="headerlink" title="仍在准备：域内路由选择到DNS服务器"></a>仍在准备：域内路由选择到DNS服务器</h3><ol start="14">
<li>网关路由器接收该帧并抽取包含DNS查询的IP数据报。根据转发表将数据报发送到Comcast网络中最左边的路由器。</li>
<li>最左边的路由器接收到了该帧，抽取IP数据报过后确定转发接口。</li>
<li>包含该DNS查询的IP数据报到达了DNS服务器。服务抽取包含<a target="_blank" rel="noopener" href="http://www.google.com的dns源记录.该dns服务器形成了一个包含这种主机名到ip地址映射的dns回答报文,并且放到udp报文段中,最后反向转发到学校的路由器,最后到bob的笔记本./">www.google.com的DNS源记录。该DNS服务器形成了一个包含这种主机名到IP地址映射的DNS回答报文，并且放到UDP报文段中，最后反向转发到学校的路由器，最后到Bob的笔记本。</a></li>
<li>做完了大量的准备工作，现在Bob笔记本准备接触谷歌的服务器了。</li>
</ol>
<h3 id="Web客户-服务器交互：TCP和HTTP"><a href="#Web客户-服务器交互：TCP和HTTP" class="headerlink" title="Web客户-服务器交互：TCP和HTTP"></a>Web客户-服务器交互：TCP和HTTP</h3><ol start="18">
<li>此时Bob笔记本已经有了谷歌服务器的IP地址，就能够生成TCP套接字了，这个套接字用于向<a target="_blank" rel="noopener" href="http://www.google.com发送http/">www.google.com发送HTTP</a> GET报文。当Bob生成套接时候，TCP必须先和<a target="_blank" rel="noopener" href="http://www.google.com中的tcp执行三次握手./">www.google.com中的TCP执行三次握手。</a></li>
<li>三次握手的过程略。</li>
<li>最后Bob的笔记本可以将HTTP GET报文写到套接字中，成为一个TCP报文段的荷载。</li>
<li>谷歌的HTTP服务器从TCP套接字中读取HTTP GET报文，生成一个HTTP响应报文，将请求的Web页内容放入HTTP响应体中，并发送进TCP套接字。</li>
<li>Bob的笔记本接收到了这个报文，并抽取出来Web网页的HTML，并在浏览器上显示了这个HTML。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/06/computer-networking/computer-networking-chapter4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/06/computer-networking/computer-networking-chapter4/" class="post-title-link" itemprop="url">计算机网络第四章学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-06 19:51:56" itemprop="dateCreated datePublished" datetime="2020-02-06T19:51:56+08:00">2020-02-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>负责主机到主机通信服务的具体工作。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h3><p>网络层的作用是将分组从一台主机移动到另一台主机。为此，需要两种重要的网络层功能：</p>
<ul>
<li><strong>转发</strong>。分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。</li>
<li><strong>路由选择</strong>。分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法称为<strong>路由选择算法（routing algorithm）</strong>。</li>
</ul>
<p>转发和路由选择是<strong>有区别</strong>的。转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。路由选择是指网络范围的过程，决定分组从源到目的地所采取的端到端路径。  </p>
<p>每台路由器都具有一张<strong>转发表（forwarding table）</strong>。路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在该路由器的转发表种索引查询。<br><img src="http://hollin.icu/CN-4-2.png" alt="4-2路由算法决定转发表中的值">  </p>
<p>某些分组交换机称为<strong>链路层交换机（link-layer switches）</strong>，基于链路层的字段中的值做转发决定。<br>基于网络层字段的值做转发决定的分组交换机称为<strong>路由器（router）</strong>。  </p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性。<br>考虑网络层能够提供的某种可能的服务。当运输层向网络层传递一个分组时，能由网络层提供的特定服务包括：</p>
<ul>
<li>确保交付。</li>
<li>具有时延上界的确保交付。</li>
<li>有序分组交付。</li>
<li>确保最小带宽。</li>
<li>确保最大时延抖动。</li>
<li>安全性服务。</li>
</ul>
<p>网络层提供了单一的服务，称为<strong>尽力而为的服务（best-effort service）</strong>。（无服务的一种委婉说法）<br><img src="http://hollin.icu/CN-4-table-1.png" alt="4-1表"><br>ATM（Asynchronous Transfer Mode）网络体系结构提供了多重服务模型，其中最重要的两个是：</p>
<ul>
<li><strong>恒定比特率（Constant Bit Rate, CBR）ATM网络服务</strong>。这种服务的目标就是使网络连接看起来就像在发送方与接收方之间存在一条i专用的，固定带宽的传输链路。使用CBR服务，可以保证端到端的时延、丢失等比率都保持在特定值以下。</li>
<li><strong>可用比特率（Available Bit Rate, ABR）ATM网络服务</strong>。对于这个服务的连接来说，最小的信元传输速率（MCR）是可以得到保证的。如果在给定时间内网络由足够的空闲资源，发送方也可以用比MCR更高的速率成功的发送速率。</li>
</ul>
<h2 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h2><p>网络层连接和无连接服务于运输层面向连接和无连接服务有类似之处，但也存在巨大差异：</p>
<ul>
<li>网络层中，这些服务是网络层向运输层提供的主机到主机的服务。在运输层中，这些服务则是运输层向应用层提供的进程到进程的服务。</li>
<li>网络层只能提供主机到主机的无连接服务或者主机到主机的连接服务。提供连接服务的计算机网络称为<strong>虚电路（Virtual-Circuit, VC）网络</strong>；仅在网络层提供无连接服务的计算机网络称为<strong>数据报网络（datagram network）</strong>。</li>
</ul>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p>因特网是一个数据报网络。但是许多其他网络体系结构中（ATM、帧中继的体系结构）中却是虚电路网络，因此在网络层中使用连接。这些连接被称为<strong>虚电路</strong>。<br>虚电路的组成：</p>
<ol>
<li>源和目的主机之间的路径。</li>
<li>VC号，沿着该路径的每段链路的一个号码。</li>
<li>沿着该路径的每条路由器中的转发表项。</li>
</ol>
<p>简单来说就是有一张网，网里面的结点不是主机就是分组交换机。两个主机想要建立连接，首先得把两台主机连起来。连起来的过程中肯定就形成了一条路径，这个路径由很多段构成。每个段也得编个号，就是VC号。分组交换机就负责查转发表，然后按这个路径把分组从一段传到另一段，直到传给接收方。<br>转发表可能长这个样子：  </p>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">入VC号</th>
<th align="center">出接口</th>
<th align="center">出VC号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">12</td>
<td align="center">2</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">63</td>
<td align="center">1</td>
<td align="center">18</td>
</tr>
<tr>
<td align="center">···</td>
<td align="center">···</td>
<td align="center">···</td>
<td align="center">···</td>
</tr>
</tbody></table>
<p>无论何时跨越一台路由器创建一条新的虚电路，转发表就增加了一个新表项。同理中止时相应的表项就被删除。<br>为什么要反复添加删除表项呢？首先如果要保持所有的VC号，那么VC字段的长度势必会变长。并且如果沿着某个路径的所有链路要求一个共同的VC号势必会导致路由器交换大量的报文来约定一个共同的VC号。  </p>
<p>在虚电路网络中，该网络的路由器必须为进行中的<strong>连接维持连接状态信息（connection state information）</strong>。<br>虚电路中的3个明显不同的阶段：</p>
<ul>
<li>虚电路建立。</li>
<li>数据传送。图4-4。</li>
<li>虚电路拆除。</li>
</ul>
<p><img src="http://hollin.icu/CN-4-4.png" alt="4-4虚电路建立"><br>路由器之间的传递的用于建立虚电路的报文称<strong>信令报文（signaling message）</strong>，用来交换这些报文的协议称为<strong>信令协议（signaling protocol）</strong>。</p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>分组转发。通过IP地址来转发分组。采用最长前缀匹配规则（longest prefix matching rule）。</p>
<h3 id="虚电路和数据报网络的由来"><a href="#虚电路和数据报网络的由来" class="headerlink" title="虚电路和数据报网络的由来"></a>虚电路和数据报网络的由来</h3><p>虚电路就很像打电话，采用了真正的电路，电路交换也是电话界的术语。面向虚电路的网络比面向数据报网络复杂的多。  </p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>网络层的<strong>转发功能（forwarding function）</strong>：将分组从一台路由器的入链接传送到适当的出链接。<br><img src="http://hollin.icu/CN-4-6.png" alt="4-6路由器体系结构">  </p>
<ul>
<li>输入端口。功能：<ul>
<li>执行 将一条输入的物理链路与路由器相连接的物理层 的功能。</li>
<li>执行 需要与位于入链路远端的数据链路层交互 的数据链路层功能。</li>
<li>完成查找功能。通过查询转发表决定路由器的输出端口。</li>
<li>控制分组从输入端口转发到路由选择处理器。</li>
</ul>
</li>
<li>交换结构。将输入端口和输出端口相连。</li>
<li>输出端口。</li>
<li>路由选择处理器。执行路由选择协议，维护路由选择表以及链接的链路状态信息。</li>
</ul>
<p>路由器的输入端口、输出端口和交换结构共同实现了转发功能，并且总是用硬件实现，这些转发功能有时候总称为<strong>路由器转发平面（router forwarding plane）</strong>。用硬件实现转发功能出于以下考虑：</p>
<ul>
<li>考虑10Gbps的带宽输入链路和64个字节的IP数据包，那么当下一个数据包到来之前留给路由器的时间仅有51.2ns。这个速度只能靠硬件实现。</li>
</ul>
<p>当转发平面以纳秒级运行时，路由器的控制功能以毫秒或秒的时间尺度上运行。  </p>
<p><img src="http://hollin.icu/CN-4-metaphor.png" alt="书上给出了一个很好的类比">  </p>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p><img src="http://hollin.icu/CN-4-7.png" alt="4-7输入端口处理"><br>输入端口中的查找对于路由器的运行是至关重要的。路由器使用转发表来查找输出端口，使得到达的分组将能够经过交换结构转发到该输出端口。<br>转发表是由路由选择处理器计算和更新的，但是每个输入端口实际上都有转发表的一份影子副本。有了影子副本，转发决策能在每个输入端口本地做出选择，无需调用中央路由选择处理器，避免了集中式处理的瓶颈。<br>假设转发表存在，从概念上来说查表是比较简单的。但是在具有较大输入链路的带宽的情况下，我们的查表不能用简单的线性搜索技术。所以快速查找算法是必要的。<br>一旦通过查找确定了某分组的输出端口，则改分组就能够发送进入交换结构。在一些设计中，如果来自其他端口的分组当前正在是用该交换结构，此时其他的分组可能被暂时阻塞进入交换结构。因此，一个被阻塞的分组必须要在输入端口处排队，并等待稍后被及时调度以通过交换结构。  </p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p><img src="http://hollin.icu/CN-4--8.png" alt="4-8三种交换技术">  </p>
<ul>
<li><strong>经内存交换</strong>。最简单、最早的路由器是传统的计算机，在输入端口和输出端口之间的交换功能是在CPU的直接控制下完成的。在这种情况下假设内存带宽为每秒B个分组，那么很显然总的转发吞吐量一定不会大于B/2。同时也可以注意到该方式不能同时转发两个分组，因为系统总线一次只能进行一次内存的读写。</li>
<li><strong>经总线交换</strong>。在这种情况下，输入端口经一根共享总线将分组直接传送到输入端口，不需要路由选择处理器的干预。</li>
<li><strong>经过互联网络交换</strong>。例如横纵式网络。在这种网络下可以并行转发多个分组。</li>
</ul>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p><img src="http://hollin.icu/CN-4-9.png" alt="4-9输出端口处理">  </p>
<h3 id="何时出现排队"><a href="#何时出现排队" class="headerlink" title="何时出现排队"></a>何时出现排队</h3><p>假定输入线路速度和输出线路速度式相同的，均为每秒$R_{line}$个分组，有N个输出端口和N个输入端口。定义交换结构传送速率$R_{switch}$为从输入端口到输出端口能够移动分组的速率。如果$R_{switch}$比$R_{line}$快N倍，那么在输入端口处几乎不会出现排队。<br>可是输出端口接收每个分组都需要耗费一个单位时间，在这种情况下，输入端口的内存很快就会被占满，进而造成分组被丢弃。<br><img src="http://hollin.icu/CN-4-10.png" alt="4-10输出端口排队"><br>分组在输出端口排队的后果就是需要在输出端口上配备一个<strong>分组调度程序（packet scheduler）</strong>。如果没有足够的缓存来缓存一个入分组，那么必须做出决定：丢弃新到的分组或者删除一个或多个排队的分组。<br>如果说在缓存还未满的情况下就丢弃一个分组，那么这种策略被统称为<strong>主动队列管理（Active Queue Management，AQM）算法</strong>。</p>
<p>如果交换结构不够快，那么在输入端口也有可能出现分组排队。<br><img src="http://hollin.icu/CN-4-11.png" alt="4-11输入排队HOL阻塞"></p>
<h2 id="网际协议：因特网中的转发和编址"><a href="#网际协议：因特网中的转发和编址" class="headerlink" title="网际协议：因特网中的转发和编址"></a>网际协议：因特网中的转发和编址</h2><p><img src="http://hollin.icu/CN-4-12.png" alt="4-12网络层的内部视图">  </p>
<h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="http://hollin.icu/CN-4-13.png" alt="4-13IPv4数据报格式">  </p>
<ul>
<li>版本号。四个比特规定了数据报的IP协议版本。路由器能够通过版本号确定如何解释IP数据报的剩余部分。</li>
<li>首部长度。四个比特，确定数据报中数据部分实际从哪里开始的。一般的IP数据报具有20字节的首部。</li>
<li>服务类型。用于区分不同的IP数据报。</li>
<li>数据报长度。IP数据报的总长度，以字节计。该字段有16个比特，理论上来说支持的最大长度为65535字节，但是实际上数据报很少有超过1500字节的。</li>
<li>标识、标志、片偏移。与IP分片有关，IPv6不允许在路由器上对分组分片。</li>
<li>寿命（Time-To-Live， TTL）字段用来确保数据不会永远在网络中循环。数据报每经过一个路由器，该字段的值减1。若TTL为0，则路由器必须丢弃该数据报。</li>
<li>协议。用以指示IP数据报的数据应该交付给哪个特定的运输层协议。值为6则表示交给TCP，值为17则表明交给UDP。</li>
<li>首部检验和。用于帮助路由器检测收到的IP数据报中的比特错误。每两个字节当作一个数，用反码运算对这些数求和。</li>
<li>源和目的IP地址。</li>
<li>选项。允许IP首部被拓展。</li>
<li>数据（有效荷载）。</li>
</ul>
<h4 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h4><p>一个链路层帧嫩承载的最大数据量叫<strong>最大传送单元（Maximum Transmission Unit, MTU）</strong>。<br>不是所有的链路层协议都能承载相同长度的网络层分组。一个路由器连着几条不同的链路，这些链路可能运行具有不同MTU的链路层协议。假设有一个数据报的长度大于这条链路运行协议的MTU，这时候路由器必须将IP数据报分成两片甚至多片才能成功将数据从这条链路发送出去。每个较小的数据报都称为<strong>片（fragment）</strong>。<br>IPv4的设计者感到如果在路由器中组装数据报会给协议带来相当大的复杂性并且会影响路由器性能。因此IPv4的设计者决定将数据报重新组装的工作交给端系统。<br><img src="http://hollin.icu/CN-4-14.png" alt="4-14IP分片与重新组装"><br>分片可能导致DoS攻击并且使得路由器和端系统更为复杂。  </p>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p>主机与路由器连入网络的方法：一台主机通常只有一条链路连接到网络；主机与物理链路之间的边界叫<strong>接口（interface）</strong>。<br>考虑一台路由器及其接口。路由器的任务式从链路上接收数据并从某些其他的链路转发出去，所以路由器必须拥有两条或者更多条链路与他相连。IP要求每条主机和路由器接口拥有自己的IP地址，因此，一个IP地址技术上式与一个接口相关联的，而不是与包括该接口的主机或路由器相关联的。<br>每个IP地址长度为32比特，共有$2^{32}$个可能的IP地址。这些地址一般按照所谓的<strong>点分十进制法（dotted-decimal notation）</strong>书写：每个字节用它的十进制形式书写，各字节间以.隔开。<br>如193.32.216.193的二进制法是：<br>$$11000001 00100000 11011000 00001001$$<br>所以在因特网中的每台主机的每个接口，必须有一个全球唯一的IP地址（NAT后面的接口除外）。然而，这些地址不能随意的自由选择，一个接口的IP地址的一部分需要由器连接的子网来决定。<br><img src="http://hollin.icu/CN-4-15.png" alt="4-15接口地址和子网"><br>如图4-15，一台路由器用于互联7台主机。左上角的三台主机最左侧24比特是相同的。这四个接口通过一个并不包含路由器的网络互联起来。<br>用IP的术语来说，互联这三个主机接口与一个路由器接口的网络形成了一个<strong>子网（subnet）</strong>。IP编址为这个子网分配了一个地址：223.1.1.0/24，其中/24的记法称为<strong>子网掩码（network mask）</strong>，指示了32比特中的最左侧24位定义了子网地址。因此子网223.1.1.0/24是由三台主机接口和一个路由器接口组成，任何其他要连接到223.1.1.0/24网络的主机都要求其地址具有223.1.1.xxx的形式。<br><img src="http://hollin.icu/CN-4-17.png" alt="4-17三条路由器互联六个子网"><br>一个子网IP定义不局限于连接堕胎主机到一个路由器接口的以太网段。在4-17中，三团云分别是三个子网。同时三条点对点链路是三个不同的子网。<br><strong>为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫做一个子网（subnet）。</strong><br>因特网的地址分配策略被称为<strong>无类别域间路由（Classless Interdomain Routing, CIDR）</strong>。<br>形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的<strong>前缀（prefix）</strong>。一个组织通常被分配一块连续的地址。<br>一个地址的剩余32-x比特可认为u是用于区分该分组内部设备的。其中所有设备具有相同的网络前缀。当该组织内部的路由器转发分时候，才会考虑这些比特。这些较低的比特可能具有另外的子网结构。<br>在CIDR被采用之前，IP地址的网络部分被限制子为长度为8、16或24比特。这是一种称为<strong>分类编址（classful addressing）</strong>的编址方式。这是因为具有8、16和24比特子网地址的子网分别被称为A、B和C类网络。这种要求使得在支持数量迅速增长的具有小规模或中规模子网的组织方面出现了问题。一个C类的子网仅能容纳$2^8-2=254$台主机（其中有两个预留用于特殊用途），这对于许多组织来说太小了。而一个B类网络多达65535台主机又太多了。<br>当一台主机发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机。楼尤其也会又选择地向临近的子网转发该报文。</p>
<h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><p>为了获取一块IP地址用于一个住址的网络，某网络管理员也许首先会于他的ISP联系。该ISP可能会从已分给他的更大地址块中提供一些地址。IP地址由<strong>因特网名字和编号分配机构（Internet Corporation for Assigned Names and Numbers, ICANN）</strong>管理。</p>
<h4 id="获取主机地址：动态主机配置协议DHCP"><a href="#获取主机地址：动态主机配置协议DHCP" class="headerlink" title="获取主机地址：动态主机配置协议DHCP"></a>获取主机地址：动态主机配置协议DHCP</h4><p>当我们获取了一块IP地址过后，我们就可以给我们的主机和路由器接口逐个分配IP地址。显然，我们可以手动配置，但是更多的是通过<strong>动态主机配置协议（Dynamic Host Configuration, DHCP）</strong>来进行的。<br>网络管理员能够配置DHCP，使得某给定主机每次于网络连接时能够得到一个相同的IP地址，或者某主机将分配一个临时的<strong>IP地址（temporary IP address）</strong>，该地址每次连入网络时可能是不同的。<br>由于DHCP具有能够将主机接入一个网络的网络相关方面的自动能力，又被称为<strong>即插即用协议（plug-and-play protocol）</strong>。非常省事。<br>DHCP是一个客户-服务器协议。如果在某子网中没有服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理直到该网络的DHCP服务器的地址。<br><img src="http://hollin.icu/CN-4-21.png" alt="4-21客户-服务器交互"><br>对于一台新到达的主机而言，DHCP协议是四个步骤的过程：</p>
<ul>
<li><strong>DHCP服务器发现</strong>。一台新到的主机首要任务事发现一个要与其交互的DHCP服务器。这可以通过使用一个<strong>DHCP发现报文（DHCP discover message）</strong>来完成。客户在UDP分株中向端口67发送在发现报文。DHCP客户生成包含DHCP发现报文的IP数据报，使用广播的目的地址255.255.255.255并使用本主机的源地址0.0.0.0。DHCP客户将该IP数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的子网。</li>
<li>DHCP服务器提供。DHCP服务器收到一个DHCP发现报文时，用一个<strong>DHCP提供报文（DHCP offer message）</strong>向客户做出响应，使用IP广播地址。</li>
<li>DHCP请求。新到达的客户从一个或者多个服务器中选择一个，并向选中的服务器提供一个<strong>DHCP请求报文（DHCP request message）</strong>进行响应，回显配置参数。</li>
<li>DHCP ACK。服务器用DHCP（DHCP ACK message）对DHCP请求报文进行响应，证实所要求的参数。</li>
</ul>
<h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>每个IP使能的设备都需要一个IP地址。在这种情况下，如果说家里有很多台设备需要同时联网，在ISP划分给家庭的IP地址不够的情况下该怎么办呢？有一个简单的方法可以解决这个情况：<strong>网络地址转换（Network Address Translation, NAT）</strong>。<br><img src="http://hollin.icu/CN-4-22.png" alt="4-22网络地址转换"><br>所谓的网络地址转换，就是让路由器对于外部设备来说不像一台路由器，反而它的行为像是一个具有单一IP地址的单一设备。<br>如图4-22，在家庭内部的四个接口都具有相同的网络地址：10.0.0.0/24。地址空间10.0.0.0/8时在RFC 1918中保留的三部分IP地址空间之一，这些地址用于家庭网络等专用网络或具有专用地址的<strong>地域（realm）</strong>。地域的意思是地址对该网络中的设备有意义的网络。出了这个特定范围就没有意义。在这种情况下，所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址138.76.29.7。NAT使路由器隐藏了家庭网络的细节。<br>NAT通过NAT转换表将LAN端的数据报进行修改，生成一个新的源端口号并且将IP地址修改成138.76.29.7。这样一来，他的六万多个端口就可以对应六万多个专用IP。<br>NAT在近年来被广泛使用，然而它也被IETF团队的纯化论者反对。主要出于几个原因：</p>
<ul>
<li>端口号是用于进程编址的，而不是用于主机编址的。</li>
<li>路由器应该处理高达第三层的分组。</li>
<li>NAT违反了端到端协议（主机之间应该直接对话，结点不应该修改IP地址和端口号）。</li>
<li>使用IPv6来解决IP短缺的问题，而不应该使用NAT。</li>
</ul>
<p>NAT的另一个问题是它很影响P2P应用程序。因为P2P应用程序需要两台主机直接相连。</p>
<h4 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h4><p>NAT穿越越来越多由即插即用的UPnP提供。</p>
<h4 id="因特网控制报文协议ICMP"><a href="#因特网控制报文协议ICMP" class="headerlink" title="因特网控制报文协议ICMP"></a>因特网控制报文协议ICMP</h4><p>ICMP被主机和路由器用来彼此沟通网络层的信息。最经典的用贴图是差错报告。<br>ICMP通常被认为是IP的一部分，但是从实际功能上来说它是处于IP之上的，因为它的报文是承载在IP分组中的。<br>ICMP报文有一个类型字段和一个编码字段。<br><img src="http://hollin.icu/CN-4-23.png" alt="4-23ICMP报文类型">  </p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><p><img src="http://hollin.icu/CN-4-24.png" alt="4-24IPv6数据报格式"><br>IPv6相比较于IPv4的变化有：</p>
<ul>
<li>扩大的地址容量。IPv6中将地址长度从32比特增加到了128比特。</li>
<li>简化高效的40字节首部。</li>
<li><strong>流（flow）</strong>标签与优先级。流字段可用于给属于特殊流的分组加上标签，这些流是发送方要求进行特殊处理的流。可以是音频或者视频的传输。优先级…</li>
</ul>
<p>IPv6中定义的字段有：</p>
<ul>
<li>版本。显然当该字段中的值为6时指示当前使用的IP版本为IPv6。</li>
<li>流量类型。和IPv4中的TOS类似。</li>
<li>流标签。</li>
<li>有效荷载长度。16比特，给出了IPv6数据报中跟在定长的40字节首部后面的<strong>字节</strong>长度。</li>
<li>下一个首部。替代了IPv4中的协议类型以及选项。</li>
<li>跳限制。</li>
<li>源地址和目的地址。</li>
<li>数据。</li>
</ul>
<p>和IPv6相比，IPv4中有几个字段已经不复存在：</p>
<ul>
<li>分片/重新组装。</li>
<li>首部和检验。在IPv4中，TTL字段每经过一个路由器都会被减一，路由器就需要重新计算数据报的首部检验和，相当耗时。</li>
<li>选项。</li>
</ul>
<h4 id="从IPv4到IPv6的迁移"><a href="#从IPv4到IPv6的迁移" class="headerlink" title="从IPv4到IPv6的迁移"></a>从IPv4到IPv6的迁移</h4><p>IPv6可以使得系统做成向后兼容，但是IPv4的系统不能够处理IPv6的数据报。那么从IPv4迁移到IPv6可能采用以下几种方法。</p>
<ol>
<li>选定一个标志日，从这个标志日的某个时间开始，因特网所有的机器都关机并从IPv4升级到IPv6。技术迁移。</li>
<li><strong>双栈（dual-stack）</strong>方法。路由器同时拥有的处理两种版本数据报的能力。双栈的一种方法叫<strong>建隧道（tunneling）</strong>的方法。就是将IPv6的数据报的外面再套上IPv4的首部，那么IPv4的路由器以为自己处理的是一个IPv4的数据报。</li>
</ol>
<h3 id="涉足IP安全性"><a href="#涉足IP安全性" class="headerlink" title="涉足IP安全性"></a>涉足IP安全性</h3><p>现在提出了各种安全性服务的新型网络层协议。其中之一时IPsec，这是一种非常流行的安全网络层协议，在VPN中的到了广泛部署。<br>IPsec被设计为IPv4和IPv6向后兼容。使用IPsec也很简单，不需要改动任何路由器或者主机中的协议栈。两台主机之间同时使用IPsec就可以安全通信。<br>一个使用IPsec的具体例子：两台主机首先在他们之间创建一个IPsec会话。在两台主机之间的任何TCP和UDP报文段都将享受IPsec提供的安全性服务。运输层向IPsec传递一个报文段，IPsec加密这个报文段并在一个普通的IP数据报中封装得到的有效荷载。接收方的IPsec负责解密报文段并且传送给运输层。<br>IPsec提供的服务有：</p>
<ul>
<li>密码技术也顶。</li>
<li>IP数据报有效荷载的加密。</li>
<li>数据完整性。</li>
<li>初始鉴别。</li>
</ul>
<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>主机通常直接与一台路由器相连，该路由器称为该主机的<strong>默认路由器（default router）</strong>，也称为<strong>第一跳路由器（first-hop router）</strong>。每当主机发送一个分组时，分组被传送给他的默认路由器，将这个路由器称为<strong>源路由器（source router）</strong>，把目的主机的路由器称为<strong>目的路由器（destination router）</strong>。<br>路由选择算法的目的：给定一组路由器以及连接路由器的链路，路由选择算法苏泽找到一条从源路由器到目的路由器的“好”路径。实际上路由问题转化成了图的问题。<br>在这种情况下，路由算法可以具体分为两种：</p>
<ul>
<li><strong>全局式的路由选择算法（global routing algorithm）</strong>用完整的、全局性的网络知识计算从源到目的地之间的最低费用路径。在这种情况下，网络中所有的路由器以及链路的状态都需要在开始时输入系统。具有全局状态信息的算法被称为<strong>链路状态（Link State，LS）算法</strong>。</li>
<li>分散式路由选择算法（decentralized routing algorithm）以迭代、分布式的方式计算出最低费用路径。没有结点拥有关于所有网络链路费用的完整信息。一个结点逐渐计算出到达某个目的结点的最低费用。这种算法被称为一个<strong>距离向量（Distance-Vector，DV）算法</strong>。</li>
</ul>
<p>或者分为<strong>静态路由选择算法</strong>或者<strong>动态路由选择算法</strong>。</p>
<ul>
<li>静态路由选择算法需要人工配置转发表。</li>
<li>动态路由选择算法能够根据网络流量负载或者拓扑的变化而选择路径。</li>
</ul>
<p>或者分为负载敏感算法（load-sensitive algorithm）或者负载迟钝（load-insensitive algorithm）算法。</p>
<h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><p>在链路状态算法中，网络拓扑和所有的链路费用都是已知的。那么每个链路的特征和费用都需要作为输入输入到系统中。在实践中由<strong>链路状态广播（link state broadcast）</strong>完成。通常可以使用Dijkstra算法完成。</p>
<h3 id="距离向量路由选择-待详学"><a href="#距离向量路由选择-待详学" class="headerlink" title="距离向量路由选择-待详学"></a>距离向量路由选择-待详学</h3><p>距离向量（Distance-Vector，DV）算法是一种迭代的、异步的和分布式的算法。<br>Bellman-Ford方程。</p>
<h3 id="层次路由选择-跳过"><a href="#层次路由选择-跳过" class="headerlink" title="层次路由选择-跳过"></a>层次路由选择-跳过</h3><p>在LS和DV的算法研究中，我们将网络看做成一个互联路由器的集合。在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有一点简单化，至少有以下两个重要原因：</p>
<ul>
<li>规模。随着路由器的数目变得很大，涉及路由选择信息计算、存储及通信的开销将高得不可实现。</li>
<li>管理自洽。如某公司要求按照自己的意愿运行路由器。</li>
</ul>
<p>这两个问题都可以通过将路由器组织进<strong>自洽系统（Autonomous System，AS）</strong>来解决。每个AS由一组通常出来相同管理控制下的路由器组成。在相同AS下的路由器全部都运行同样的路由选择算法。在一个自洽系统内运行的路由选择算法叫做<strong>自洽系统内部路由选择协议（intra-autonomous system routing protocol）</strong>。负责在本AS之外的目的地转发分组的路由器被称为<strong>网关路由器（gateawy router）</strong>。<br>自然而言的，两个相邻的AS之间的路由选择协议称为自洽系统间的路由选择协议（inter-autonomous system routing protocol）。两个相邻的AS之间必须运行相同的路由选择协议。事实上，因特网间所有的AS中都运行者相同的路由选择协议BGP4。  </p>
<h2 id="因特网中的路由选择协议"><a href="#因特网中的路由选择协议" class="headerlink" title="因特网中的路由选择协议"></a>因特网中的路由选择协议</h2><h4 id="因特网中自洽系统内部的路由选择：RIP"><a href="#因特网中自洽系统内部的路由选择：RIP" class="headerlink" title="因特网中自洽系统内部的路由选择：RIP"></a>因特网中自洽系统内部的路由选择：RIP</h4><p>AS内部路由选择协议又称为<strong>内部网关协议（interior gateway protocol）</strong>。历史上有两个路由选择协议曾被广泛用于因特网上自洽系统内的路由选择：<strong>路由选择信息协议（Routing Information Protocol, RIP）</strong>与<strong>开放最短路优先（Open Shortest Path First，OSPF）</strong>。<br>RIP是最早的AS内部因特网路由选择协议之一，并且目前仍在广泛使用。他是一种距离向量协议。费用被定义在路由对之间，从源路由器到目的子网的最短路径所经过的子网数量被称为<strong>跳</strong>。<br>路由选择更新的信息通过一种<strong>RIP响应报文（RIP response message）</strong>进行交换，又被称为<strong>RIP通告（RIP advertisement）</strong>。</p>
<h3 id="因特网中自洽系统内部的路由选择：OSPF"><a href="#因特网中自洽系统内部的路由选择：OSPF" class="headerlink" title="因特网中自洽系统内部的路由选择：OSPF"></a>因特网中自洽系统内部的路由选择：OSPF</h3><p>OSPF是一个使用了洪泛链路状态信息的链路状态协议和一个Dijkstra最低费用路径算法。  </p>
<h3 id="自洽系统间的路由选择：BGP"><a href="#自洽系统间的路由选择：BGP" class="headerlink" title="自洽系统间的路由选择：BGP"></a>自洽系统间的路由选择：BGP</h3><p><strong>边界网关协议（Border Gateway Protocol，BGP）</strong>为每个AS提供了进行以下工作的手段：</p>
<ol>
<li>从相邻的AS处获得子网可达性信息。</li>
<li>向本AS内部的说有路由器传播这些可达性信息。</li>
<li>基于可达性信息和AS策略，决定到达子网的“好”路由。</li>
</ol>
<h4 id="BGP基础——待深入"><a href="#BGP基础——待深入" class="headerlink" title="BGP基础——待深入"></a>BGP基础——待深入</h4><p>BGP极其复杂但是绝对是因特网中之绝对至关重要的协议。  </p>
<h2 id="广播和多播路由选择"><a href="#广播和多播路由选择" class="headerlink" title="广播和多播路由选择"></a>广播和多播路由选择</h2><h3 id="广播路由选择算法"><a href="#广播路由选择算法" class="headerlink" title="广播路由选择算法"></a>广播路由选择算法</h3><p>最简单的方式是<strong>N次单播（N-way-unicast）</strong>：直接准备N个副本，修改一下目的地并向N个目的地传输这N个分组。但是这个方法的缺点也很明显：</p>
<ul>
<li>效率低。源节点需要发送N个分组出去。</li>
<li>接收方都需要被发送方已知。</li>
</ul>
<p>在这种情况下，网络结点本身在分组复制、转发和广播是比较好的。</p>
<h4 id="无控制洪泛"><a href="#无控制洪泛" class="headerlink" title="无控制洪泛"></a>无控制洪泛</h4><p>实现广播最简单的技术是<strong>洪泛（flooding）</strong>方法，他要求源节点向他的所有邻居发送分组的副本。但如果网络拓扑中有一个圈，就会导致每个广播的一个分组将无休止的循环。当一个结点与两个以上的结点连接时，将会导致网络中生成大量的广播分组，产生<strong>广播风暴（broadcast storm）</strong>。</p>
<h4 id="受控洪范"><a href="#受控洪范" class="headerlink" title="受控洪范"></a>受控洪范</h4><p>避免广播风暴的关键是每个结点明智选择何时洪泛分组，何时不洪泛分组。有以下几种方式：</p>
<ul>
<li><strong>序号控制洪泛（sequence-number-controlled flooding）</strong>，源结点将其地址以及<strong>广播序号（broadcast sequence number）</strong>放入广播分组，再向它的所有邻居发送该分组。每个结点维护它已经收到的、复制的和转发的源地址和每个广播分组的序号列表。当结点接收到一个广播分组时，首先检查分组是否再列表中，如果在，丢弃该发呢组，如果不在就复制并转发。</li>
<li><strong>反向路径转发（Reverse Path Forwarding，RPF）</strong>。当一台路由器收到具有给定源地址的广播分组时，仅当该分组到达的链路正好是位于它自己的返回其源的最短单波路径上，才向其他所有出链路传输报文；否则就丢弃这个报文。（源地址在转发的过程中不会变）</li>
</ul>
<h4 id="生成树广播"><a href="#生成树广播" class="headerlink" title="生成树广播"></a>生成树广播</h4><p>找一个最小生成树然后发送广播分组，广播分组只能生成树的路径中进行转发。</p>
<h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p>广播是将分组交付给网络中的所有结点，多播分组仅被交付给网络结点中的一个子集。在实际中，一些新兴的网络应用要求将分组从一个或多个发送方交付给一组接收方。<br>在多播通信中面临两个问题：</p>
<ul>
<li>怎样标识多播分组的接收方。</li>
<li>怎样为发送到这些接收方的分组编址。</li>
</ul>
<p>显然，标识所有的多播分组接收方的IP地址是行不通的。因此多播数据使用<strong>间接地址（address indirection）</strong>来编址。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/02/course/c++/C%E8%AF%AD%E8%A8%80%E8%80%83%E7%82%B9%E5%BD%92%E7%BA%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/02/course/c++/C%E8%AF%AD%E8%A8%80%E8%80%83%E7%82%B9%E5%BD%92%E7%BA%B3/" class="post-title-link" itemprop="url">C语言考点归纳</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-02 22:48:59" itemprop="dateCreated datePublished" datetime="2020-02-02T22:48:59+08:00">2020-02-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="易错知识点"><a href="#易错知识点" class="headerlink" title="易错知识点"></a>易错知识点</h2><ul>
<li>常见字符ASCII码。<ul>
<li>回车CR、’\n’：10</li>
<li>字符串结尾’\0’、NULL：0</li>
</ul>
</li>
<li>C语言整型常量可以用十进制，八进制，十六进制表示，唯独不能用二进制来表示。<ul>
<li>0x开头是十六进制</li>
<li>0开头是八进制</li>
<li>1-9开头是十进制</li>
</ul>
</li>
<li>for(k = 2; k == 0; )执行0次。</li>
<li><code>lo + (hi - lo) / 2</code>与<code>lo + (hi - lo) &gt;&gt; 1</code>结果不同，因为加的优先级高于右移…很容易错。</li>
<li>C语言中转义字符后面跟的数字是以八进制读取的，<code>\101</code>实际上是字符<code>A</code>。</li>
<li><code>*p++</code>与<code>++*p</code>的区别。<a target="_blank" rel="noopener" href="https://blog.csdn.net/ljytower/article/details/85045739">区别详解</a>。</li>
<li><code>int a[5];</code>，<code>&amp;a + 1</code>的结果是数组最后一个元素后面的地址。</li>
<li>指针相减得到的结果就是在内存中的距离，无需除sizeof(类型)。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/31/computer-networking/computer-networking-chapter3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/31/computer-networking/computer-networking-chapter3/" class="post-title-link" itemprop="url">计算机网络第三章学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-31 16:29:38" itemprop="dateCreated datePublished" datetime="2020-01-31T16:29:38+08:00">2020-01-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>运输层位于应用层和网络层之间，是分层网络体系结构中的重要部分。  </p>
<h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信（logic communication）</strong>。简而言之就是两台主机之间好像是直接相连的。应用进程使用运输层提供的逻辑通信互相发送报文，不许考虑承载这些报文的物理设备。<br>实际上运输层的协议是在端系统中实现的<strong>而不是在路由器中实现的</strong>（我的确认为是在路由器里面实现的，哈哈）。运输层的协议在端系统中实现，并且将应用层中的报文转化为运输层分组<strong>报文段（segment）</strong>。网络层将报文段封装成数据报。网络路由器实际上只作用于这个数据报。</p>
<p><img src="http://hollin.icu/CN-3-1.png" alt="运输层在应用进程间提供逻辑的而非物理的通信"><br>从图3-1中也可以看出来，这个连接两个不同局域网的路由器实际上就只到得了网络层，运输层的协议不是由它实现的。<br>网络应用程序可以使用多种的运输层协议。因特网由两种协议，即TCP和UDP。每种协议都能为调用的应用程序提供以组不同的运输层服务。</p>
<h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p>网络层提供了<strong>主机</strong>之间的逻辑通信，而运输层为运行在不同主机之上的<strong>进程</strong>提供了逻辑通信。<br>书上给出了一个非常好的例子：考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。这两家的孩子们喜欢彼此之间写信，每个人每星期要相互写一封信，每封信都用单独的信封通过传统的邮政服务传送。每一个家庭都有一个孩子负责发邮件，西海岸家庭是Ann而东海岸家庭是Bill。每星期Ann去它的所有兄弟姐妹那里收集信件，并将这些信件交付到每天到家门口来的邮政服务的邮车上。Bill和Ann做同样的工作。<br>在这个例子里面：</p>
<ul>
<li>邮政服务车为两个家庭提供了逻辑通信</li>
<li>Ann和Bill为他们家的兄弟姐妹们提供了逻辑通信</li>
<li>在Ann和Bill的兄弟姐妹眼里，邮件服务是Ann和Bill提供的，尽管Ann和Bill要把信件送到邮车上。</li>
</ul>
<p>所以在这个例子里面：</p>
<ol>
<li>应用层报文——信封里面的字符</li>
<li>进程——堂兄弟姐妹</li>
<li>主机（端系统）——房子</li>
<li>网络层协议——邮车</li>
<li>运输层协议——Ann和Bill</li>
</ol>
<p>那我们可以看到，Ann和Bill实际上是在房子里面做他们的工作的，所以说运输层协议确实是由端系统实现的。<br>假定Ann和Bill外出度假，另一对兄妹接替他们的工作，这个时候我们相当于把运输层协议换了一个。相当于从TCP换成UDP。</p>
<h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>在学习UDP和TCP之前，需要简要了解一下因特网的网络层。因特网网络协议层有一个名字叫<strong>IP</strong>，即<strong>网络协议</strong>。IP为<strong>主机之间</strong>提供了逻辑通信。IP的服务模型是<strong>尽力而为交付服务（best-effort delivery service）</strong>，这意味着IP尽它“最大的努力”在同行的主机之间交付报文段，但不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按需交付，不保证报文段中数据的完整性。出于这些原因，IP被称为<strong>不可靠服务（unreliable service）</strong>。<br>在有了对IP服务模型有了初步的了过后，我们总结一下UDP和TCP所提供的服务模型。UDP和TCP最基本的责任是，将两个端系统间的IP交付服务拓展为运行在端系统上的两个进程之间的交付服务。将主机之间的交付拓展到进程之间的交付被称为<strong>运输层的多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>。</p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p><img src="http://hollin.icu/CN-3-2.png" alt="3-2运输层的多路复用和多路分解"><br>一个进程由一个或多个<strong>套接字（socket）</strong>，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。所以在接收主机的运输层实际上并没有直接将数据交付给进程，而且将数据交付给了一个中间的套接字。<br>那么主机怎样将一个到达的运输层报文定向到适当的套接字呢？为了达到这个目的，每个运输层报文段中<strong>具有几个字段</strong>。在接收端，运输层检查这些字段，标识处接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解（demultiplexing)**。而在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作称为</strong>多路复用（multiplexing）**。<br>和前面两个家庭的例子联系起来，Ann和Bill收集兄弟姐妹们的信件的过程实际上就是一个多路复用的过程；相反的，从邮车里面把信件分发给各个兄弟姐妹的过程就是一个多路分解的过程。<br>在上述的讨论中我们知道运输层多路复用的要求：</p>
<ol>
<li>套接字有一个唯一的标识符；</li>
<li>每个报文段有特殊字段来指示该报文段索要交付到的套接字。</li>
</ol>
<p><img src="http://hollin.icu/CN-3-3.png" alt="3-3运输层报文段中的源与目的端口字段"><br>这些特殊字段是<strong>源端口号字段（source port number field）</strong>和<strong>目的端口号字段（destination port number field）</strong>。端口号是一个16比特的数，大小在0<del>65535之间。0</del>1023范围的端口号称为<strong>周知端口号（well-know port number）</strong>，是受限的，保留给HTTP以及FTP等周知应用层协议来使用。</p>
<h3 id="无连接的多路复用与多路分解"><a href="#无连接的多路复用与多路分解" class="headerlink" title="无连接的多路复用与多路分解"></a>无连接的多路复用与多路分解</h3><p>假定在主机A中的一个进程具有UDP端口191517，它要发送一个应用程序数据块位于主机B中的一个进程具有UDP端口464248。主机A中的运输层船舰一个运输层报文段，其中包括应用程序数据，源端口号（191517）、目睹端口号（46428）和其他两个值。然后运输层将得到的报文段传递给网络层。网络层将该报文段封装到一个IP数据包中，并尽力交付给接收主机。如果该报文顺利到达接收主机B，接收主机运输层就检查该报文段中目的端口字段并将报文段交付给对应的套接字。<br>一个UDP套接字是由一个二元组来全面标识的，该二元组包含一个目的IP地址和一个目的端口号。如果两个UDP报文段由不同的源IP地址和/或端口号，但是<strong>具有相同的目的IP地址和目的端口号</strong>，那么这两个报文段将通过相同的目的套接字被定向到<strong>相同的目的进程</strong>。<br><img src="http://hollin.icu/CN-3-4.png" alt="3-4源端口号与目的端口号的反转">  </p>
<h3 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h3><p>TCP套接字与UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源IP地址， 源端口号，目的IP地址， 目的端口号）来识别的。这样，当一个TCP报文段从网络到达一台主机时候，该主机使用全部四个值来讲报文段定向（分解）到响应的套接字。与UDP不同的是，<strong>两个具有不同的源IP地址或源端口号的到达TCP将被定向到两个不同的套接字</strong>，除非TCP报文段写带了初始创建连接的请求。<br>服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由四元组来标识每个套接字。当一个TCP报文到达主机时候，所有的四个字段都将被用来将报文段分解到相应的套接字。</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>应用选用UDP的原因主要有一下几点：</p>
<ul>
<li>关于何时、发送什么数据的应用层控制更为精细。采用UDP只需要应用进程将数据传递给UDP，UDP就会将数据打包进UDP报文段并且理解传递给网络层。TCP相比较而言会通过三次握手建立连接并且受限于拥塞控制。</li>
<li>无需连接建立。</li>
<li>无连接状态。</li>
<li>分组首部开销小。</li>
</ul>
<p><img src="http://hollin.icu/CN-3-6.png" alt="3-6流行的因特网应用以及其下的运输协议"><br>实际上可以在应用层面上拓展UDP，使其实现可靠数据传输。这样就可以避免TCP的拥塞控制机制并且保证进程的可靠通信。缺点是会导致开发人员的开发周期以及调试难度增大。</p>
<h4 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h4><p><img src="http://hollin.icu/CN-3-7.png" alt="3-7UDP报文段结构"></p>
<h4 id="UDP报文检验和"><a href="#UDP报文检验和" class="headerlink" title="UDP报文检验和"></a>UDP报文检验和</h4><p>UDP检验和提供了差错检测的功能。发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷（所谓 “回卷” 就是当进行 16 比特的加法运算的时候，如果进位到 17位，则将第17位和后16位进行加法和运算）。得到的结果被放在UDP报文段中的检验和字段。<br>比如说我们有下面三个16比特的字：<br>$$0110011001100000$$<br>$$0101010101010101$$<br>$$1000111100001100$$<br>这16比特的字前两个的和为：<br>$$1011101110110101$$<br>此时没有溢出，不需要回卷。再将上面的和与第三个字相加，我们可以得出：<br>$$0100101011000010$$<br>此次加法有溢出，被回卷。最后我们将这串二进制字进行取反云散放到检验和字段上。<br>接收方接收到报文后只需要将全部的四个16比特字加起来，如果接收方的和为$1111111111111111$，那就说明报文没有出错。如果其中有一个比特为0，我们就可以很有信心的说报文再传送过程中出错了。<br>UDP只提供了差错检验的方法，，但是对差错是无力恢复的。所以一部分UDP的实现是丢弃出差错的报文段；而有的UDP是提供给应用进程并发出警告。</p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>书上说这是最为重要网络问题中的榜首候选者。<br><strong>可靠数据传输协议（reliable data transfer protocol）</strong>:数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特就不会收到损坏或丢失，并且所有的数据都是按照其发送顺序进行交付的。<br>要知道下层协议也许是不可靠的，因此要实现可靠数据传输是一项困难的任务。<br><img src="http://hollin.icu/CN-3-8.png" alt="3-8可靠数据传输：服务模型与服务实现">  </p>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><h4 id="经完全可靠信道的可靠数据传输：rdt-1-0"><a href="#经完全可靠信道的可靠数据传输：rdt-1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt 1.0"></a>经完全可靠信道的可靠数据传输：rdt 1.0</h4><p><img src="http://hollin.icu/CN-3-9.png" alt="3-9用于完全可靠信道的协议"><br>这个状态机没什么号说的，因为完全可靠的信道，那么发送方和接收方都可以很轻松的发送和接收分组。</p>
<h4 id="经具有比特差错信道的可靠数据传输：rdt-2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt-2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt 2.0"></a>经具有比特差错信道的可靠数据传输：rdt 2.0</h4><p>底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这些比特差错通常会出现在网络的物理部件中。<br>在这种情况下，人类一般的处理方式就是请求确认，如果双方对话过程中有一个人没说清楚，那么我们一般会让他重复一下。自然而然的，我们可以建立一个类似的协议来实现库靠数据传输协议，称之为<strong>自动重传请求（Automatic Repeat reQuest, ARQ）协议</strong>。<br>在这种情况下，我们还需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li>差错检测。自然而言的，我们需要一中方式来确认收到的分组是否出现差错。</li>
<li>接收方反馈。通过差错检测的机制我们可以检测分组是否出现差错，接着需要向发送方反馈我们的接收情况。</li>
<li>重传。当接收方接收的分组出现差错，发送方需要重传分组。</li>
</ul>
<p><img src="http://hollin.icu/CN-3-10.png" alt="3-10用于具有比特差错信道的协议"><br>图3-10的状态机很详细的描述了这一过程。<br>rdt 2.0的发送端有两个状态，发送端协议整当代来自上层传下来的数据。当产生rdt_send（data）事件时，发送方将产生一个包含待发送数据的分组，然后经由udt_send（sndpkt）发送这个分组。在右边的状态中我们需要等待接收方的ACK或者NAK分组。如果收到一个ACK分组，说明发送的分组被无差错地接收，这时我们就可以返回到等待上层调用的状态。注意到下列事实很重要：当发送方处于等待ACK或NAK的状态时，它无法从上层获得更多的数据。在这种行为下，rdt 2.0这样的协议被称为<strong>停等（stop-and-wait）</strong>协议。<br>rdt 2.0接收方的状态机任然只有一个状态。当分组到达时，接收方要么回答一个ACK，要么回答一个NAK。<br>rdt 2.0看上去好像可以运行了，但是它有一个致命的缺陷：ACK或NAK的分组可能受损！（我确实也以为可以运行了哈哈哈）那么我们至少需要在ACK或者NAK中添加检验和比特来检测这样的差错。更男的问题是协议应该怎样纠正ACK和NAK分组中的差错。<br>处理受损ACK和NAK时的三种可能性：</p>
<ul>
<li>考虑发送方的可能做法。不具备可操作性。</li>
<li>增加足够的检验和比特，使发送方不仅可以检测差错，还可以恢复差错。如果有这样的技术为什么不直接采用呢…</li>
<li>发送方接收到含糊不清的ACK或者NAK分组时，只需要重传当前数据分组即可。这样虽然会导致一点<strong>冗余分组（duplicate packet）</strong>。冗余分组的根本困难在接收方不知道它上次发送的ACK或者NAK是否被发送方正确的收到，因此它就不知道这个分组是新的分组还是重传的分组。</li>
</ul>
<p>在数据分组中添加一个字段，发送方对其数据分组编号，将发送数据分组的<strong>序号（sequence number）</strong>放在该字段。那么接收方只需要检查序号则可以确定接收到的分组是不是一次重传。<br>对于停等协议这种简单情况，一个比特的序号就足够了，它可以让接收方知道发送方是否正在重传前一个发送分组。<br><img src="http://hollin.icu/CN-3-11.png" alt="3-11rdt2.1发送方"><br><img src="http://hollin.icu/CN-3-12.png" alt="3-12rdt2.1接收方">  </p>
<h4 id="经具有比特差错的丢包信道的可靠数据传输：rdt-3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输：rdt-3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：rdt 3.0"></a>经具有比特差错的丢包信道的可靠数据传输：rdt 3.0</h4><p>有很多可能的方法用于解决丢包问题。最简单的就是发送方在等待足够长的时间中都没有接收到接收方的响应分组，那么我们就可以确定分组已经丢失，进而发送方重传分组。<br>发送方需要等待多久才能确认分组已经丢失呢？很明显发送方至少要等待发送方与接收方之间的一个往返时延加上接收方处理一个分组所需的时间。然而在很多网络中，想要确定最坏情况下的最大时延是很难估算的。<br>因此在实际中的做法是发送方明智的选择一个时间值，以判定可能发生了丢包。如果在这个时间内没有收到ACK，则重传该分组。在这种情况下可能出现<strong>冗余数据分组（duplicate data packet）</strong>。通过序号的方法我们已经处理了冗余分组的情况。<br>在这种基于时间的重传机制下，需要一个<strong>倒计数计时器（countdown timer）</strong>，在一个给定的时间量过后，可以中断发送方。因此，发送方需要能够：</p>
<ol>
<li>每次发送一个分组时便启动一个定时器。</li>
<li>响应定时器中断。</li>
<li>中止定时器。</li>
</ol>
<p><img src="http://hollin.icu/CN-3-15.png" alt="3-15rdt3.0发送方"><br><img src="http://hollin.icu/CN-3-16.png" alt="3-16rdt3.0的运行，比特交换协议"></p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p>书上基于rdt 3.0停等协议分析了完整发送一个分组所需的时间以及链路的利用率，指出停等协议是十分浪费网络资源的。因此我们采用一种<strong>流水线（pipelining）</strong>的技术来向接收方发送分组。流水线技术对于可靠数据传输协议会产生以下的影响：</p>
<ul>
<li>必须增加序号范围。因为每个运输中的分组必须有一个唯一的序号，而且也须有多个在传输中未确认的报文。</li>
<li>协议的发送方和接收方必须缓存多个分组。发送方最少应该缓存没有被接收方确认的分组；接收方至少能够缓存已经正确接收的分组。</li>
<li>所需的序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线的差错恢复有两种基本方式：<strong>回退N步（Go-Back_N, GBN）</strong>和<strong>选择重传（Selective Repeat, SR）</strong>。</li>
</ul>
<h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><p>回退N步协议允许发送方发送多个分组而不需要等待确认。但是流水线中的分组数不允许超过最大步数N。<br><img src="http://hollin.icu/CN-3-19.png" alt="3-19在GBN中发送方看到的序号"><br>在图3-19中可以看到，处于base号之前的分组是已发送并且已经确认接收的分组.处于base到nextseqnum之间的分组是已发送但是未被确认的分组。nextseqnum是下一个待发分组的序号。处于nextseqnum到窗口长度的最后一个分组的序号能用于那些要被立即发送的分组，大于窗口长度的最后一个分组的序号是不能被使用的，直到当前流水线中未被确认的分组（特别是base）得到确认过后为止。<br><img src="http://hollin.icu/CN-3-20.png" alt="3-20GBN发送方的拓展FSM描述"><br><img src="http://hollin.icu/CN-3-21.png" alt="3-21GBN接收方的拓展FSM描述"><br>GBN发送方必须响应三种类型的事件：</p>
<ul>
<li>上层的调用。当上层调用rdt_send()时，发送方首先检测发送窗口是否已满。未满的话就发送这个分组，否则只需要将数据换回给上层，隐式地指示上层该窗口已满。在实际现实中只需要做一个同步机制即可。</li>
<li>收到一个ACK。在GBN协议中，对于序号为N的分组的确认采取的是<strong>累计确认（cumulative acknowledgment）</strong>的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。</li>
<li>超时事件。出现超时发送方重传已发送但是还未被确认过的分组。</li>
</ul>
<p>接收方的动作也很简单。如果一个序号为n的分组被正确接收到，并且上次交付给上层的数据是序号为n-1的分组，那么接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。<br>在GBN协议中，接收方丢弃所有的失序分组。接收方必须按序号将数据交付给上层。  </p>
<p>GBN协议缺点：</p>
<ol>
<li>存在性能问题。当窗口长度和带宽时延积都很大时，单个分组就可能引起GBN重传大量分组，尽管很多分组根本没有必要重传。</li>
</ol>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错（丢失或受损）的分组而避免了不必要的重传。<br><img src="http://hollin.icu/CN-3-23.png" alt="3-23选择重传发送方与接收方的序号空间"><br>在选择重传的情况下，发送方的窗口大小和接收方的窗口大小就有一定的讲究。书上给了两种情况：<br><img src="http://hollin.icu/CN-3-27.png" alt="3-27接收方窗口太大"><br>对于a)情况和可以很明显的看到，发送方重传的分组0在接收方看来是无法确定的，接收方不知道是ACK分组接收失败还是新的序号为0的分组。b)情况中也是一样。a)和b)分别说明了不管是发送方还是接收方都无法保证不出现丢包的情况。<br>书上提出了这个问题，对于窗口大小需要做出一定的限制。查阅了相关资料过后想明白了这个问题：接收窗口大小不能大于$2^n$，n为序号的位数。为了解释这个问题，首先要想清楚两个问题：</p>
<ul>
<li>发送方的窗口大小能否大于接收方的窗口大小？<ul>
<li>发送方的窗口大小大于接受方的窗口大小无意义。因为接收方的窗口大小固定，那么一部发送方的分组是无论如何无法缓存的。</li>
</ul>
</li>
<li>接收方的窗口大小能否大于发送方的窗口大小？<ul>
<li>接收方的窗口大于发送方的窗口也无意义。发送方能发送的分组数量一定少于接收方的窗口大小，因此接收方的一部分空间是浪费掉的。</li>
</ul>
</li>
</ul>
<p>所以接收方的窗口大小等于发送方的窗口大小是一个合理的解决方案。基于这种条件下，如果发送方的窗口和接收方的窗口重合，那么就一定会产生无法确定是首次发送还是重传的分组。比如说序号位数为2且窗口大小为3：<br>$$发送方：012 30123$$<br>$$接收方：012 301 23$$<br>对于发送方，012还未确认；012的确认分组已经发出；此时无法确保012的确认分组能够顺利到达发送方，因此发送方发出的下次发出的0号分组在接收方的眼中也不能确定是重传还是新的分组。<br>当窗口大小为2时，这时将不会产生分组的二义性。</p>
<p><img src="http://hollin.icu/CN-3-table1.png" alt="3-1表可靠传输机制及其用途的总结">  </p>
<h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP被称为<strong>面向连接的（connection-oriented）</strong>。<br>因为这种TCP“连接”状态保留在两个端系统中，所以它不是一条端到端的电路，也不是一条虚电路。TCP只运行在端系统中，而不再中间的网络元素中运行，因此路由器对于TCP连接完全视而不见，他们看到的是数据报，而不是连接。<br>TCP连接提供的是<strong>全双工服务（full-duplex service）</strong>：数据可以从A主机流向B，也可以从B主机流向A。<br>TCP连接建立的过程：客户端首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。其中，前两个报文段不承载有效荷载，而第三个报文段可以承载有效荷载。这个过程称为三次握手（three-way handshake）。<br>数据从客户进程向服务器进程发送数据的过程：</p>
<ol>
<li>客户进程通过套接字将传递数据流。</li>
<li>TCP将这些数据引导到该连接的<strong>发送缓存（send buffer）</strong>。</li>
<li>TCP时不时从发送缓存中取出一块数据。TCP规范中并没有体积应该何时实际发送缓存里的数据，只描述为“TCP应该在它方便的时候以报文段的形式发送数据”。TCP从缓存中取出的数据受限于<strong>最大报文段长度（Maximum Segment Size, MSS）</strong>。MSS取决于最大链路层帧长度，即<strong>最大传输单元（Maximum Transmission Unit, MTU）</strong>。以太网和PPP链路层协议都具有1500字节的MTU，预留出40字节给TCP/IP首部，典型的MSS长度为1460字节。</li>
<li>TCP为取出的数据配上一个TCP首部，从而形成多个<strong>TCP报文段（TCP Segment）</strong>。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中，并发送到网络中。</li>
<li>TCP在另一端接收到一个报文段后，报文段数据就被放入TCP连接的接收缓存中。</li>
<li>应用程序从接收缓存中读取数据流。</li>
</ol>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="http://hollin.icu/CN-3-29.png" alt="3-29TCP报文段结构"><br>TCP发送大文件时，将会把该文件划分成长度为MSS的若干块。<br>首部包括<strong>源端口号</strong>，<strong>目的端口号</strong>，用于多路复用/分解。TCP首部也包括<strong>检验和字段（checksum field）</strong>。同时还包括：</p>
<ul>
<li>32比特的<strong>序号字段（sequence number field）</strong>和32比特的<strong>确认号字段（acknowledgment number field）</strong>，用于实现可靠数据传输服务。</li>
<li>16比特的<strong>接收窗口字段（receive window field）</strong>，用于流量控制。用于指示接收方愿意接收的字节数量。</li>
<li>4比特的<strong>首部长度字段（header length field）</strong>。指示了以32比特的字作为单位的TCP首部长度。</li>
<li>可选与变长的<strong>选项字段（option field）</strong>。</li>
<li>6比特的<strong>标志字段（flag field）</strong>。<ul>
<li>ACK比特用与对一个已被成功接收报文段的确认。</li>
<li>RST、SYN和FIN比特用于连接建立和拆除。</li>
<li>PSH比特用于指示接收方应该立即将数据交给上层。</li>
<li>URG比特用于指示报文段里存在被发送端上层置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据<strong>指针字段指出</strong>。</li>
</ul>
</li>
</ul>
<h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>TCP把数据堪称是一个无结构、有序的字节流。<br>一个<strong>报文段的序号（sequence number for a segment）</strong>是该报文段首字节的字节流编号。也就是说A给B发送数据时在报文段中的序号字段添上报文段的序号。<br>TCP是全双工的，因此A在向B发送报文段的同时，B也有可能需要向A发送报文段。因此确认号中填的内容是自己所希望从对方获取的报文段序号的数据。  </p>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><h4 id="估计往返时间（未深究）"><a href="#估计往返时间（未深究）" class="headerlink" title="估计往返时间（未深究）"></a>估计往返时间（未深究）</h4><p>报文段的样本RTT就是从某报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一次SampleRTT的测量，而不是为每个发送的报文段测量一个SampleRTT。</p>
<h4 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>TCP在IP不可靠的尽力而为服务之上创建了一种<strong>可靠数据传输服务（reliable data transfer service）</strong>，确保一个进程从其接收缓存中读出的数据流是无损坏，无间隔，非冗余和按序的数据流。<br>那么一个只包括超时重传的简化TCP的工作过程如下图：<br><img src="http://hollin.icu/CN-3-33.png" alt="3-33简化的TCP发送方">  </p>
<h4 id="几种有趣的情况"><a href="#几种有趣的情况" class="headerlink" title="几种有趣的情况"></a>几种有趣的情况</h4><p><img src="http://hollin.icu/CN-3-34.png" alt="3-34确认丢失而重传"><br>图3-34中的确认的分组丢失导致主机A超时重传。<br><img src="http://hollin.icu/CN-3-35.png" alt="3-35报文段100没有重传"><br>图3-35中主机A采用流水线技术发送分组，一次发送了两个分别包含八个字节数据以及二十个字节数据的分组。两个确认分组都没有顺利返回发送方A导致超时，此时发送方只会重传第一个分组。当ACK = 120的分组顺利接收时主机A不会重传任何一个分组。（累计确认）</p>
<h4 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h4><p>每当超时时间发生时，TCP重传具有最小序号的还未被确认的报文段。每次TCP的重传时都会将下次的超时间隔设置为之前的<strong>两倍</strong>而不是用EstimatedRTT和DevRTT推算出来的值。很容易看出来，超时间隔在每次重传过后会以指数型增长。超时间隔会在<strong>收到新的数据</strong>以及<strong>收到ACK分组</strong>后重新使用EstimatedRTT和DevRTT推算得到。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>超时触发重传存在的问题之一时<strong>超时周期可能相对较长</strong>。发送方可以在超时时间发生之前通过<strong>冗余ACK（duplicate ACK）</strong>来检测到丢包的情况。<br>那么我们首先要搞清楚什么情况下接收方会发送冗余ACK。图3-2中列出了产生TCP ACK的建议。<br><img src="http://hollin.icu/CN-3-table1.png" alt="3-2表产生TCPACK的建议"><br>因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，他就把当成一种指示，跟在这个已被确认过三次的报文段之后的半文端已经丢失。一旦收到三个冗余ACK，TCP就执行<strong>快速重传（fast retransmit）</strong>。<br>关于为什么是三次冗余ACK就启动快速重传的原因：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21789252">三次ACK快速重传原理</a></p>
<h4 id="是回退N步还是选择重传"><a href="#是回退N步还是选择重传" class="headerlink" title="是回退N步还是选择重传"></a>是回退N步还是选择重传</h4><p>TCP采取的策略既不是GBN也不是选择重传，更像是一种混合体。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP提供<strong>流量控制服务（flow-control service）</strong>以消除发送方使接收方缓存溢出的可能性。TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制称为<strong>拥塞控制（congestion control)**。（两个不同的术语）<br>TCP通过让发送方维护一个称为</strong>接收窗口（receive window）**的变量来提供流量控制。接收窗口就是用来指示发送方——该接收方还有多少可用的缓存空间。TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。<br>假设主机A通过一条TCP连接向主机B发送了一个大文件。主机B为该链接分配了一个接收缓存，RcvBuffer表示其大小。有以下定义：</p>
<ul>
<li>LastByteRead：主机B上的应用程序从缓存中读出的数据流的最后一个字节的编号。</li>
<li>LastByteRcvd：从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号。</li>
</ul>
<p>由于TCP不允许已分配的缓存溢出，那么下面的等式必须成立：<br>$$LastByteRcvd - LastByteRead \le RcvBuffer$$<br>接收窗口用rwnd表示，根据缓存可用空间的数量来设置：<br>$$rwnd = RcvBuffer - [lastByteRcvd - LastByteRead]$$<br>该空间是动态变化的，所以rwnd是动态的。<br>连接通过rwnd提供流量控制服务的方式：</p>
<ul>
<li>主机B通过把当前的rwnd值放入它发送给主机A的报文段接收窗口字段中，通知主机A它的缓存中还有多少可用空间。开始时rwnd=RcvBuffer，同时跟踪几个与连接有关的变量。</li>
<li>主机A也需要跟踪两个变量，LastByteSent和LastByteAcked。那么LastByteAcked - LastByteSent就是主机A发送但未被确认的数据量。那么A在连接的整个生命周期内必须保证：<br>$$LastByteSent - LastByteAcked \le rwnd$$</li>
</ul>
<p>TCP仅当在它有数据或者有确认要发送才会发送报文段给主机A。在这种情况下，如果B没有数据要发送给A，并且B的rwnd=0已经发送给A了，那么A就会一直处于堵塞的状态。所以在这种情况下A会继续给B主机发送只有一个字节数据的报文段，这些报文段将会被接收方确认。并且确认报文里面含一个非0的rwnd值。</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP连接是如何建立的：</p>
<ul>
<li>第一步：客户端TCP首先向服务器端的TCP发送一个特殊的TCP报文段。这个报文段中不包含应用层的数据。报文段的首部中SYN标志位被置为1。这个报文段被称为SYN报文段。客户会随机选择一个初始序号（client_isn），并将这个编号放置到TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。</li>
<li>第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机。服务器会从该数据报中提出TCP SYN报文段，并未该TCP连接分配缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是首部却包含三个重要的信息。<ol>
<li>首部的SYN比特被置为1。</li>
<li>TCP首部的确认号字段被置为client_isn + 1。</li>
<li>服务器选择自己的初始序号server_isn，并将其放置到TCP报文段首部的序号字段中。</li>
</ol>
</li>
<li>第三步：收到SYNACK报文段后，客户也需要给该链接分配缓存和变量。客户主机则向服务器发送另一个报文段；这个报文段对服务器的讯息连接的报文段进行了确认。因为连接已经建立了，SYN比特被置为0。这一步中客户可以在报文段负载中写带客户到服务器的数据。</li>
</ul>
<p><img src="http://hollin.icu/CN-3-39.png" alt="3-39TCP三次握手：报文段交换"><br>TCP连接的中止：</p>
<ul>
<li>任何一方都可以中止该连接。连接结束后，主机中的资源将被释放。</li>
<li>TCP连接中止具体过程如图3-40。<ol>
<li>客户发送一个将FIN比特置为1的报文段，服务器返回对这个报文段的确认报文段。</li>
<li>服务器向客户发送一个将FIN置为1的报文段，客户返回这个报文段的确认报文段。</li>
</ol>
</li>
</ul>
<p><img src="http://hollin.icu/CN-3-40.png" alt="3-40关闭一条TCP连接"><br><img src="http://hollin.icu/CN-3-41.png" alt="3-41客户TCP经历的典型的TCP状态序列">  </p>
<p>SYN泛洪攻击（SYN flood attack）：由于服务器在响应客户的SYN时分配了相关资源，如果客户不发送ACK来完成该三次握手的第三步，那么服务器在某一时间段内的资源就被浪费掉了。SYN泛洪攻击就是利用这一点，在短时间内发送大量的TCP SYN报文段，导致服务器的连接资源被消耗殆尽。  </p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h3><h4 id="情况1：两个发送方和一台具有无穷大缓存的路由器"><a href="#情况1：两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="情况1：两个发送方和一台具有无穷大缓存的路由器"></a>情况1：两个发送方和一台具有无穷大缓存的路由器</h4><p><img src="http://hollin.icu/CN-3-43.png" alt="3-43拥塞情况1：两条连接共享具有无限大缓存的单跳路由"><br>输出链路容量为R，两个发送方A和B，两个接收方C和D。<br><img src="http://hollin.icu/CN-3-44.png" alt="3-44拥塞情况1：吞吐量、时延与主机发送速率的函数关系"><br>很显然，接收方只能以$R/2$的吞吐量接收分组。当发送方A、B发送分组的速度超过$R/2$将会导致大量分组排在路由器的缓存队列中。即发送方发送分组的速度超过$R/2$将会导致大量分组在路由器中排队。<br>从时延的图中可以看到，虽然很容易先入为主的想充分利用输出链路，因此取得$R/2$的每连接吞吐量应该是最合适的，但是事实恰好相反。<br>从吞吐量的角度来看，运行在总吞吐量接近R的状态也许是一个理想状态，但是从时延的角度来看，却远不是一个理想状态。</p>
<h4 id="情况2：两个发送方和一台具有有限缓存的路由器"><a href="#情况2：两个发送方和一台具有有限缓存的路由器" class="headerlink" title="情况2：两个发送方和一台具有有限缓存的路由器"></a>情况2：两个发送方和一台具有有限缓存的路由器</h4><p>在这种情况下，由于路由器的缓存是有限的，将导致已满缓存的路由器丢弃到达的分组。<br><img src="http://hollin.icu/CN-3-45.png" alt="3-45两台主机与一台拥有有限缓存的路由器"><br><img src="http://hollin.icu/CN-3-46.png" alt="3-46具有有限缓存的情况2的性能"><br>在这种情况下，a）是分组不丢失的情况，b）是平均角度下（即$1/3$的概率重发分组）分组丢失的情况，c）是大时延的情况。</p>
<h4 id="情况3：四个发送方和具有有限缓存的多台路由器"><a href="#情况3：四个发送方和具有有限缓存的多台路由器" class="headerlink" title="情况3：四个发送方和具有有限缓存的多台路由器"></a>情况3：四个发送方和具有有限缓存的多台路由器</h4><p><img src="http://hollin.icu/CN-3-47.png" alt="3-47四个发送方和具有有限缓存的多台路由器"><br>在这种情况下，当一个分组沿着一条路径被丢弃时，每个上游路由器用于转发改分组到丢弃该分组而使用的传输容量最终被浪费掉了。<br><img src="http://hollin.icu/CN-3-48.png" alt="3-48性能图">  </p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>根据网络层是否为运输层拥塞控制提供显式帮助区分拥塞控制方法：</p>
<ul>
<li><strong>端到端的拥塞控制</strong>。在这种情况下，网络层没有为运输层提供<strong>显式支持</strong>。也就是说运输层判断是否出现拥塞全靠自己。</li>
<li><strong>网络辅助的拥塞控制</strong>。在这种情况下，网络层构件方发送方提供关于网络中拥塞状态的显示反馈信息。</li>
</ul>
<p>对于网络辅助的拥塞控制，拥塞信息反馈到发送方一般采用两种方式：</p>
<ul>
<li>网络路由器直接发送给发送方。这种形式通常直接发送一个<strong>阻塞分组（choke packet）</strong>。</li>
<li>第二种形式是路由器标记分组中的某个字段来指示产生了拥塞。接收方接收到了被标记的分组后就会向发送方通知该网络拥塞指示。这种形式的通知至少要经过一个完整的往返时间。</li>
</ul>
<h3 id="网络辅助拥塞控制例子：ATM-ABR拥塞控制"><a href="#网络辅助拥塞控制例子：ATM-ABR拥塞控制" class="headerlink" title="网络辅助拥塞控制例子：ATM ABR拥塞控制"></a>网络辅助拥塞控制例子：ATM ABR拥塞控制</h3><p>了解。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP采用的是端到端的拥塞控制。<br>TCP所采用的方法是让每一个发送方根据所感知到的网络来限制其能向连接发送流量的速率。如果发送方感觉网络不拥塞，TCP发送方增加其发送速率；反之限制其发送速率。在这种方法下有三个需要解决的问题：</p>
<ol>
<li>一个TCP发送方如何限制它向其连接发送流量的速率。</li>
<li>一个TCP发送方如何感知它到目的地路径上存在拥塞。</li>
<li>当发送方感知到了拥塞，该采用什么算法来改变其发送速率。</li>
</ol>
<p>TCP发送方如何限制其连接发送流量的。在有拥塞的情况下，发送方还需要跟踪一个额外的变量：<strong>拥塞窗口（congestion window）</strong>。表示为cwnd。在这种情况下：<br>$$LastByteSent - LastByAcked \le min(cwnd, rwnd)$$<br>通过限制cwnd的值，我们就可以控制发送数据的速率了。  </p>
<p>TCP发送方是如何感知它与目的地之间的路径上出现了拥塞。如果出现了以下两种情况之一即说明路径出现了拥塞：</p>
<ul>
<li>接收到三个冗余ACK。说明极大可能丢包。</li>
<li>超时。极大可能出现丢包。</li>
</ul>
<p>当确认以较快的速度到达时，拥塞窗口将会增长迅速；当确认以较慢速度到达时，拥塞窗口将会增长缓慢。TCP使用确认来触发增大它的拥塞窗口长度，因此是<strong>自计时（self-clocking）</strong>的。  </p>
<p>尽管这样，问题还是没有得到解决：TCP发送方如何确认它应当的发送速率。如果发送太快，将会导致网络拥塞。太慢了又不能很好地利用网络带宽。TCP采用下列的指导性原则：</p>
<ul>
<li>一个丢失的报文段表意味着拥塞，因此当求实报文段时应该降低TCP发送方的速率。</li>
<li>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达，能够增加发送方的速率。</li>
<li>带宽探测。</li>
</ul>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP连接开始时，cwnd的值通常设置为一个MSS的较小值。如果MSS=500字节且RTT=200ms，那么初始发送速率大概只有20kbps。实际上可用带宽可能比20kbps大得多，因此在慢启动（slow-start）状态，cwnd的值以1一个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。<br><img src="http://hollin.icu/CN-3-51.png" alt="3-51TCP慢启动"><br>TCP虽然启动的时候cwnd设置为一个MSS，但是它的增长速度为指数型。<br>对于这种指数增长何时结束的几种方案：</p>
<ol>
<li>当产生了丢包事件，TCP发送方将cwnd设置为1并且重新开始慢启动过程。同时将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2。</li>
<li>产生丢包事件时直接与ssthresh值相关联。检测到拥塞时将ssthresh设为cwnd的值的一半。当cwnd的值等于sshtresh时结束慢启动并且TCP转移到拥塞避免模式。</li>
<li>检测到三个冗余ACK时候执行一种快速重传并进入快速恢复状态。</li>
</ol>
<p><img src="http://hollin.icu/CN-3-52.png" alt="3-52TCP拥塞控制的FSM描述"><br>TCP拥塞控制的有限状态机。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>一旦进入拥塞避免状态，那么cwnd的值大约是上次遇到拥塞时的值的一半，距离拥塞并不遥远。所以TCP不能盲目地将cwnd的值翻倍，而是采用一个较为保守的办法，每个RTT只将cwnd的值增加一个MSS。<br>在这种情况下，丢包事件出现时，ssthresh的值被更新为cwnd值的一半。但是丢包事件中超时的情况更为严重，而收到三个冗余ACK的情响下处理不应该这么剧烈。因此当收到三个冗余ACK时，将ssthresh的值设置cwnd的一半，接下来进入快速恢复阶段。</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>很显然如果丢包事件是三次冗余ACK，网络拥塞的概率很低，如果直接将cwnd重新置为1是很浪费网络带宽的行为。TCP早期版本Tahoe没有实现快速恢复，而后期的Tahoe版本中实现了快速恢复，下图是分别在两种版本TCP下的拥塞窗口情况。<br><img src="http://hollin.icu/CN-3-53.png" alt="3-53TCP拥塞窗口的演化"><br>在TCP Tahoe版本中，ssthresh初值为8个MSS。前八个回合里面Tahoe和Reno采取了同样的动作。在第八个回合处出现了三次冗余ACK。在Tahoe版本下ssthresh被置为6，cwnd重置为0。而在Reno版本中，由于是三次冗余ACK导致的丢包事件，采取快速恢复，拥塞窗口设置为$ssthresh+3=9MSS$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/29/course/c++/C%E8%AF%AD%E8%A8%80scanf%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/29/course/c++/C%E8%AF%AD%E8%A8%80scanf%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">C语言scanf原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-29 14:49:57" itemprop="dateCreated datePublished" datetime="2020-01-29T14:49:57+08:00">2020-01-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="需要了解的知识点"><a href="#需要了解的知识点" class="headerlink" title="需要了解的知识点"></a>需要了解的知识点</h2><p><strong>空白字符</strong>：一般程序中的空白字符是指<strong>空格(space), ASCII:32</strong>，<strong>回车(enter),ASCII:10</strong>以及<strong>制表符(tab)，ASCII:9</strong>。<br><strong>输入缓冲区</strong>：很显然，输入缓冲区是指存放输入设备所读取输入数据的缓冲区。</p>
<h2 id="scanf输入机制"><a href="#scanf输入机制" class="headerlink" title="scanf输入机制"></a>scanf输入机制</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>scanf的函数原型如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_CRT_STDIO_INLINE int __CRTDECL scanf(</span><br><span class="line">        _In_z_ _Scanf_format_string_ char const* const _Format,</span><br><span class="line">        ...)</span><br></pre></td></tr></table></figure>
<p>从这个函数原型里面我们可以注意到scanf其实是有<strong>int类型的返回值</strong>的，查找相关文档得到返回值有以下几种类型：</p>
<ul>
<li>EOF ——键盘键入EOF以结束程序(DOS窗口中是Ctrl+Z, Unix中是Ctrl+D)</li>
<li>0 ——没有成功读入数据</li>
<li>1 ——成功读入一个数据</li>
<li>2 ——成功读入两个数据</li>
<li>···</li>
</ul>
<h3 id="对于整型-浮点型同理-输入原理测试及总结"><a href="#对于整型-浮点型同理-输入原理测试及总结" class="headerlink" title="对于整型(浮点型同理)输入原理测试及总结"></a>对于整型(浮点型同理)输入原理测试及总结</h3><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int d1, d2;</span><br><span class="line">int rev &#x3D; scanf(&quot;%d %d&quot;, &amp;d1, &amp;d2);</span><br><span class="line">printf(&quot;return value of scanf:%d, d1&#x3D;%d, d2&#x3D;%d&quot;, rev, d1, d2);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">10 20</span><br><span class="line">return value of scanf:2, d1&#x3D;10, d2&#x3D;20</span><br></pre></td></tr></table></figure>
<p>结果是正确的。但是注意到这里scanf中的格式是%d %d中间有空格，而我输入的时候也是用空格隔开的。那我在输入的格式中删除空格的话还会是这样的结果吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int d1, d2;</span><br><span class="line">int rev &#x3D; scanf(&quot;%d%d&quot;, &amp;d1, &amp;d2);</span><br><span class="line">printf(&quot;return value of scanf:%d, d1&#x3D;%d, d2&#x3D;%d&quot;, rev, d1, d2);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">10 20</span><br><span class="line">return value of scanf:2, d1&#x3D;10, d2&#x3D;20</span><br></pre></td></tr></table></figure>
<p>可以看到，结果是一样的。那修改再测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int d1, d2, d3;</span><br><span class="line">int rev &#x3D; scanf(&quot;%d %d%d&quot;, &amp;d1, &amp;d2, &amp;d3);</span><br><span class="line">printf(&quot;return value of scanf:%d, d1&#x3D;%d, d2&#x3D;%d, d3&#x3D;%d&quot;, rev, d1, d2, d3);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">10 20     30</span><br><span class="line">return value of scanf:3, d1&#x3D;10, d2&#x3D;20, d3&#x3D;30</span><br></pre></td></tr></table></figure>
<p>这样可以很明显的看出来，无论是输入格式还是输入缓冲区里的空白字符对于int类型的输入似乎都是没有影响的。那么空白字符是否还在输入缓冲区中呢？<br>写个代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int d1, d2, d3, count &#x3D; 0;</span><br><span class="line">char ch;</span><br><span class="line">int rev &#x3D; scanf(&quot;%d %d%d&quot;, &amp;d1, &amp;d2, &amp;d3);</span><br><span class="line">printf(&quot;return value of scanf:%d, d1&#x3D;%d, d2&#x3D;%d, d3&#x3D;%d\n&quot;, rev, d1, d2, d3);</span><br><span class="line">while (EOF !&#x3D; scanf(&quot;%c&quot;, &amp;ch))</span><br><span class="line">&#123;</span><br><span class="line">    if (ch &#x3D;&#x3D; 32)</span><br><span class="line">        count +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;whitespace count: %d&quot;, count);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">10 20 30</span><br><span class="line">return value of scanf:3, d1&#x3D;10, d2&#x3D;20, d3&#x3D;30</span><br><span class="line">^Z</span><br><span class="line">whitespace count: 0</span><br></pre></td></tr></table></figure>
<p>那么很显然，这里的空格被scanf处理掉了。那么也就是说，scanf在读取int类型的数据时，会处理掉输入缓冲区里的空白字符，只读取有效的int类型字符。那如果我们的输入中有非数值类型的字符呢？<br>写个测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int d1 &#x3D; 10, d2 &#x3D; 10, d3 &#x3D; 10, count &#x3D; 0;</span><br><span class="line">char ch;</span><br><span class="line">int rev &#x3D; scanf(&quot;%d %d%d&quot;, &amp;d1, &amp;d2, &amp;d3);</span><br><span class="line">printf(&quot;return value of scanf:%d, d1&#x3D;%d, d2&#x3D;%d, d3&#x3D;%d\n&quot;, rev, d1, d2, d3);</span><br><span class="line">while (EOF !&#x3D; scanf(&quot;%c&quot;, &amp;ch))</span><br><span class="line">&#123;</span><br><span class="line">    if (ch &#x3D;&#x3D; 32)</span><br><span class="line">        count +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;whitespace count: %d&quot;, count);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">c 10 20</span><br><span class="line">return value of scanf:0, d1&#x3D;10, d2&#x3D;10, d3&#x3D;10</span><br><span class="line">whitespace count: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int d1 &#x3D; 10, d2 &#x3D; 10, d3 &#x3D; 10, count &#x3D; 0;</span><br><span class="line">char ch;</span><br><span class="line">int rev &#x3D; scanf(&quot;%d %d%d&quot;, &amp;d1, &amp;d2, &amp;d3);</span><br><span class="line">printf(&quot;return value of scanf:%d, d1&#x3D;%d, d2&#x3D;%d, d3&#x3D;%d\n&quot;, rev, d1, d2, d3);</span><br><span class="line">while (EOF !&#x3D; scanf(&quot;%c&quot;, &amp;ch))</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%c&quot;, ch);</span><br><span class="line">    if (ch &#x3D;&#x3D; 32)</span><br><span class="line">        count +&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;whitespace count: %d&quot;, count);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">10 a 20</span><br><span class="line">return value of scanf:1, d1&#x3D;10, d2&#x3D;10, d3&#x3D;10</span><br><span class="line">a 20</span><br><span class="line">^Z</span><br><span class="line">whitespace count: 1</span><br></pre></td></tr></table></figure>
<p>那么从这里可以看到，scanf的返回值为0时，那么很明显d1, d2, d3都没有被读入。所以这里scanf碰到了c过后就结束读取，并且从第二段代码中可以得到scanf不会处理掉它所碰到的非int类型的字符。  </p>
<h4 id="对于整型类型的输入总结"><a href="#对于整型类型的输入总结" class="headerlink" title="对于整型类型的输入总结"></a>对于整型类型的输入总结</h4><ul>
<li>scanf不会读取输入中的空白字符，并且会丢弃碰到的空白字符。</li>
<li>scanf在碰到非整型的非法输入时会返回，并且不会处理导致返回的非法字符以及缓冲区中剩余字符。</li>
<li>scanf在碰到不符合输入格式的第一个字符时会返回，并且不会处理导致返回的非法字符以及缓冲区中的剩余字符。</li>
</ul>
<h3 id="对于字符型输入原理测试及总结"><a href="#对于字符型输入原理测试及总结" class="headerlink" title="对于字符型输入原理测试及总结"></a>对于字符型输入原理测试及总结</h3><h4 id="字符型输入原理测试"><a href="#字符型输入原理测试" class="headerlink" title="字符型输入原理测试"></a>字符型输入原理测试</h4><p>自然而然的猜测，如果输入格式里面不带空格的话，那么空格是应该会被作为字符读入的。那如果输入格式里面带空格的话，输入里面的空格会不会被过滤掉呢？写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char ch1, ch2, ch3;</span><br><span class="line">int rev &#x3D; scanf(&quot;%c %c %c&quot;, &amp;ch1, &amp;ch2, &amp;ch3);</span><br><span class="line">printf(&quot;return value of scanf:%d. ch1&#x3D;%c, ch2&#x3D;%c, ch3&#x3D;%c\n&quot;, rev, ch1, ch2, ch3);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">a             b c</span><br><span class="line">return value of scanf:3. ch1&#x3D;a, ch2&#x3D;b, ch3&#x3D;c</span><br></pre></td></tr></table></figure>
<p>这里无论输入缓冲区ab中的多个空格都被过滤掉了，也就是说输入格式中的空格匹配了所有的空白字符。当我们输入a,b,c过后按下enter，实际上缓冲区中会多余一个<strong>换行符</strong>，那么当下次读入的时候，换行符应该也会被作为一个字符被读取。写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char ch1, ch2, ch3;</span><br><span class="line">int rev &#x3D; scanf(&quot;%c %c %c&quot;, &amp;ch1, &amp;ch2, &amp;ch3);</span><br><span class="line">printf(&quot;return value of scanf:%d. ch1&#x3D;%c, ch2&#x3D;%c, ch3&#x3D;%c\n&quot;, rev, ch1, ch2, ch3);</span><br><span class="line">scanf(&quot;%c&quot;, &amp;ch1);</span><br><span class="line">printf(&quot;%d&quot;, ch1);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">a b d</span><br><span class="line">return value of scanf:3. ch1&#x3D;a, ch2&#x3D;b, ch3&#x3D;d</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意到确实输出了换行符的ASCII码。所以如果在连续输入的时候，一定要在读取输入的前清空输入缓冲区。</p>
<h4 id="字符型输入总结"><a href="#字符型输入总结" class="headerlink" title="字符型输入总结"></a>字符型输入总结</h4><ul>
<li>空白字符会被scanf作为字符读取。</li>
<li>多次读入字符数据之前一定要注意清空输入缓冲区。</li>
</ul>
<h3 id="字符串输入原理及总结"><a href="#字符串输入原理及总结" class="headerlink" title="字符串输入原理及总结"></a>字符串输入原理及总结</h3><h4 id="字符串输入测试"><a href="#字符串输入测试" class="headerlink" title="字符串输入测试"></a>字符串输入测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char str[20], ch;</span><br><span class="line">int rev &#x3D; scanf(&quot;%s&quot;, str);</span><br><span class="line">printf(&quot;return value of scanf:%d.\ninput: %s\n&quot;, rev, str);</span><br><span class="line">scanf(&quot;%c&quot;, &amp;ch);</span><br><span class="line">printf(&quot;%d&quot;, ch);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">hello</span><br><span class="line">return value of scanf:1.</span><br><span class="line">input: hello</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>这里读入一个字符串，并且以空白字符回车作为确认输入，在成功读入输入字符串后输入缓冲区中还有一个回车。如果在输入hello之前输入多个空格会不会被scanf读入呢？按照scanf对于%c输入格式的读入可以推测多个空格是会被当做输入字符串的一部分，而不会被跳过。写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char str[20];</span><br><span class="line">int rev &#x3D; scanf(&quot;%s&quot;, str);</span><br><span class="line">printf(&quot;%s&quot;, str);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">    hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>结果让我有些吃惊，这说明scanf对于%s的输入格式的匹配方式是以第一个非空白字符作为输入数据的开始。并且以碰到的第一个空白字符作为结束。</p>
<h4 id="字符串输入总结"><a href="#字符串输入总结" class="headerlink" title="字符串输入总结"></a>字符串输入总结</h4><ul>
<li>以第一个非空白字符作为输入字符串的开始，并且以接下来碰到的第一个空白字符（空白字符仍在输入缓冲区中）结束匹配。</li>
<li>和gets()函数比较而言，scanf只能读取不包含空白字符的纯字符串输入，而gets()可以读取到除EOF以及回车以外的所有字符。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>对于指定的输入格式，如”%d, %d, %d”，scanf总是会在匹配不成功的那个字符处返回，输入缓冲区中被处理过的数据将会丢失，只剩下剩余的输入数据。</li>
<li>scanf以空白字符作为分隔符，因此输入格式中的空格不会只匹配一个空白字符。也就是说，scanf对于空白字符的处理是跳过而不是硬性匹配。</li>
<li>对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和制表符都行)。也就是说如果一个scanf函数中出现scanf(“%d%d”,&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。非空白字符且非数值的输入会导致scanf从该字符的位置返回。</li>
<li>scanf在处理对字符数据（%c）的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。</li>
<li>scanf对于字符串（%s）输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个’\0’。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hollin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>






  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  





  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>




</body>
</html>
