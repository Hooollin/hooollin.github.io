<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="网络层负责主机到主机通信服务的具体工作。 概述转发和路由选择网络层的作用是将分组从一台主机移动到另一台主机。为此，需要两种重要的网络层功能：  转发。分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。 路由选择。分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法称为路由选择算法（routing algorithm）。  转发和路由选择是有区">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络第四章学习笔记">
<meta property="og:url" content="http://example.com/2020/02/06/computer-networking/computer-networking-chapter4/index.html">
<meta property="og:site_name" content="Hollin的代码之路">
<meta property="og:description" content="网络层负责主机到主机通信服务的具体工作。 概述转发和路由选择网络层的作用是将分组从一台主机移动到另一台主机。为此，需要两种重要的网络层功能：  转发。分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。 路由选择。分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法称为路由选择算法（routing algorithm）。  转发和路由选择是有区">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hollin.icu/CN-4-2.png">
<meta property="og:image" content="http://hollin.icu/CN-4-table-1.png">
<meta property="og:image" content="http://hollin.icu/CN-4-4.png">
<meta property="og:image" content="http://hollin.icu/CN-4-6.png">
<meta property="og:image" content="http://hollin.icu/CN-4-metaphor.png">
<meta property="og:image" content="http://hollin.icu/CN-4-7.png">
<meta property="og:image" content="http://hollin.icu/CN-4--8.png">
<meta property="og:image" content="http://hollin.icu/CN-4-9.png">
<meta property="og:image" content="http://hollin.icu/CN-4-10.png">
<meta property="og:image" content="http://hollin.icu/CN-4-11.png">
<meta property="og:image" content="http://hollin.icu/CN-4-12.png">
<meta property="og:image" content="http://hollin.icu/CN-4-13.png">
<meta property="og:image" content="http://hollin.icu/CN-4-14.png">
<meta property="og:image" content="http://hollin.icu/CN-4-15.png">
<meta property="og:image" content="http://hollin.icu/CN-4-17.png">
<meta property="og:image" content="http://hollin.icu/CN-4-21.png">
<meta property="og:image" content="http://hollin.icu/CN-4-22.png">
<meta property="og:image" content="http://hollin.icu/CN-4-23.png">
<meta property="og:image" content="http://hollin.icu/CN-4-24.png">
<meta property="article:published_time" content="2020-02-06T11:51:56.000Z">
<meta property="article:modified_time" content="2020-11-23T09:21:38.596Z">
<meta property="article:author" content="Hollin">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hollin.icu/CN-4-2.png">


<link rel="canonical" href="http://example.com/2020/02/06/computer-networking/computer-networking-chapter4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>计算机网络第四章学习笔记 | Hollin的代码之路</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hollin的代码之路</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E5%92%8C%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">1.1.1.</span> <span class="nav-text">转发和路由选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">网络服务模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.</span> <span class="nav-text">虚电路和数据报网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.1.</span> <span class="nav-text">虚电路网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据报网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="nav-number">1.2.3.</span> <span class="nav-text">虚电路和数据报网络的由来</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">路由器工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.3.1.</span> <span class="nav-text">输入端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">交换结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.3.3.</span> <span class="nav-text">输出端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E5%87%BA%E7%8E%B0%E6%8E%92%E9%98%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">何时出现排队</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE%EF%BC%9A%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%8F%91%E5%92%8C%E7%BC%96%E5%9D%80"><span class="nav-number">1.4.</span> <span class="nav-text">网际协议：因特网中的转发和编址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据报格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">IP数据报分片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4%E7%BC%96%E5%9D%80"><span class="nav-number">1.4.2.</span> <span class="nav-text">IPv4编址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E5%9D%97%E5%9C%B0%E5%9D%80"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">获取一块地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%EF%BC%9A%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">获取主机地址：动态主机配置协议DHCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">网络地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UPnP"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">UPnP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">因特网控制报文协议ICMP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6"><span class="nav-number">1.4.3.</span> <span class="nav-text">IPv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">IPv6数据报格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8EIPv4%E5%88%B0IPv6%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">从IPv4到IPv6的迁移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%89%E8%B6%B3IP%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.4.4.</span> <span class="nav-text">涉足IP安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">路由选择算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">链路状态路由选择算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E5%BE%85%E8%AF%A6%E5%AD%A6"><span class="nav-number">1.5.2.</span> <span class="nav-text">距离向量路由选择-待详学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E8%B7%B3%E8%BF%87"><span class="nav-number">1.5.3.</span> <span class="nav-text">层次路由选择-跳过</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.6.</span> <span class="nav-text">因特网中的路由选择协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E8%87%AA%E6%B4%BD%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9ARIP"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">因特网中自洽系统内部的路由选择：RIP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E8%87%AA%E6%B4%BD%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9AOSPF"><span class="nav-number">1.6.1.</span> <span class="nav-text">因特网中自洽系统内部的路由选择：OSPF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%B4%BD%E7%B3%BB%E7%BB%9F%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%EF%BC%9ABGP"><span class="nav-number">1.6.2.</span> <span class="nav-text">自洽系统间的路由选择：BGP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BGP%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BE%85%E6%B7%B1%E5%85%A5"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">BGP基础——待深入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E5%92%8C%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="nav-number">1.7.</span> <span class="nav-text">广播和多播路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">广播路由选择算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%8E%A7%E5%88%B6%E6%B4%AA%E6%B3%9B"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">无控制洪泛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%97%E6%8E%A7%E6%B4%AA%E8%8C%83"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">受控洪范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E5%B9%BF%E6%92%AD"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">生成树广播</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%92%AD"><span class="nav-number">1.7.2.</span> <span class="nav-text">多播</span></a></li></ol></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hollin</p>
  <div class="site-description" itemprop="description">Coder</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Hooollin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hooollin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hollinisme@gmail.com" title="E-Mail → mailto:hollinisme@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Hooollin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/06/computer-networking/computer-networking-chapter4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hollin">
      <meta itemprop="description" content="Coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hollin的代码之路">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络第四章学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-06 19:51:56" itemprop="dateCreated datePublished" datetime="2020-02-06T19:51:56+08:00">2020-02-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-23 17:21:38" itemprop="dateModified" datetime="2020-11-23T17:21:38+08:00">2020-11-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">课程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>负责主机到主机通信服务的具体工作。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h3><p>网络层的作用是将分组从一台主机移动到另一台主机。为此，需要两种重要的网络层功能：</p>
<ul>
<li><strong>转发</strong>。分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。</li>
<li><strong>路由选择</strong>。分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法称为<strong>路由选择算法（routing algorithm）</strong>。</li>
</ul>
<p>转发和路由选择是<strong>有区别</strong>的。转发是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。路由选择是指网络范围的过程，决定分组从源到目的地所采取的端到端路径。  </p>
<p>每台路由器都具有一张<strong>转发表（forwarding table）</strong>。路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在该路由器的转发表种索引查询。<br><img src="http://hollin.icu/CN-4-2.png" alt="4-2路由算法决定转发表中的值">  </p>
<p>某些分组交换机称为<strong>链路层交换机（link-layer switches）</strong>，基于链路层的字段中的值做转发决定。<br>基于网络层字段的值做转发决定的分组交换机称为<strong>路由器（router）</strong>。  </p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>网络服务模型（network service model）定义了分组在发送与接收端系统之间的端到端运输特性。<br>考虑网络层能够提供的某种可能的服务。当运输层向网络层传递一个分组时，能由网络层提供的特定服务包括：</p>
<ul>
<li>确保交付。</li>
<li>具有时延上界的确保交付。</li>
<li>有序分组交付。</li>
<li>确保最小带宽。</li>
<li>确保最大时延抖动。</li>
<li>安全性服务。</li>
</ul>
<p>网络层提供了单一的服务，称为<strong>尽力而为的服务（best-effort service）</strong>。（无服务的一种委婉说法）<br><img src="http://hollin.icu/CN-4-table-1.png" alt="4-1表"><br>ATM（Asynchronous Transfer Mode）网络体系结构提供了多重服务模型，其中最重要的两个是：</p>
<ul>
<li><strong>恒定比特率（Constant Bit Rate, CBR）ATM网络服务</strong>。这种服务的目标就是使网络连接看起来就像在发送方与接收方之间存在一条i专用的，固定带宽的传输链路。使用CBR服务，可以保证端到端的时延、丢失等比率都保持在特定值以下。</li>
<li><strong>可用比特率（Available Bit Rate, ABR）ATM网络服务</strong>。对于这个服务的连接来说，最小的信元传输速率（MCR）是可以得到保证的。如果在给定时间内网络由足够的空闲资源，发送方也可以用比MCR更高的速率成功的发送速率。</li>
</ul>
<h2 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h2><p>网络层连接和无连接服务于运输层面向连接和无连接服务有类似之处，但也存在巨大差异：</p>
<ul>
<li>网络层中，这些服务是网络层向运输层提供的主机到主机的服务。在运输层中，这些服务则是运输层向应用层提供的进程到进程的服务。</li>
<li>网络层只能提供主机到主机的无连接服务或者主机到主机的连接服务。提供连接服务的计算机网络称为<strong>虚电路（Virtual-Circuit, VC）网络</strong>；仅在网络层提供无连接服务的计算机网络称为<strong>数据报网络（datagram network）</strong>。</li>
</ul>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p>因特网是一个数据报网络。但是许多其他网络体系结构中（ATM、帧中继的体系结构）中却是虚电路网络，因此在网络层中使用连接。这些连接被称为<strong>虚电路</strong>。<br>虚电路的组成：</p>
<ol>
<li>源和目的主机之间的路径。</li>
<li>VC号，沿着该路径的每段链路的一个号码。</li>
<li>沿着该路径的每条路由器中的转发表项。</li>
</ol>
<p>简单来说就是有一张网，网里面的结点不是主机就是分组交换机。两个主机想要建立连接，首先得把两台主机连起来。连起来的过程中肯定就形成了一条路径，这个路径由很多段构成。每个段也得编个号，就是VC号。分组交换机就负责查转发表，然后按这个路径把分组从一段传到另一段，直到传给接收方。<br>转发表可能长这个样子：  </p>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">入VC号</th>
<th align="center">出接口</th>
<th align="center">出VC号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">12</td>
<td align="center">2</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">63</td>
<td align="center">1</td>
<td align="center">18</td>
</tr>
<tr>
<td align="center">···</td>
<td align="center">···</td>
<td align="center">···</td>
<td align="center">···</td>
</tr>
</tbody></table>
<p>无论何时跨越一台路由器创建一条新的虚电路，转发表就增加了一个新表项。同理中止时相应的表项就被删除。<br>为什么要反复添加删除表项呢？首先如果要保持所有的VC号，那么VC字段的长度势必会变长。并且如果沿着某个路径的所有链路要求一个共同的VC号势必会导致路由器交换大量的报文来约定一个共同的VC号。  </p>
<p>在虚电路网络中，该网络的路由器必须为进行中的<strong>连接维持连接状态信息（connection state information）</strong>。<br>虚电路中的3个明显不同的阶段：</p>
<ul>
<li>虚电路建立。</li>
<li>数据传送。图4-4。</li>
<li>虚电路拆除。</li>
</ul>
<p><img src="http://hollin.icu/CN-4-4.png" alt="4-4虚电路建立"><br>路由器之间的传递的用于建立虚电路的报文称<strong>信令报文（signaling message）</strong>，用来交换这些报文的协议称为<strong>信令协议（signaling protocol）</strong>。</p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>分组转发。通过IP地址来转发分组。采用最长前缀匹配规则（longest prefix matching rule）。</p>
<h3 id="虚电路和数据报网络的由来"><a href="#虚电路和数据报网络的由来" class="headerlink" title="虚电路和数据报网络的由来"></a>虚电路和数据报网络的由来</h3><p>虚电路就很像打电话，采用了真正的电路，电路交换也是电话界的术语。面向虚电路的网络比面向数据报网络复杂的多。  </p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>网络层的<strong>转发功能（forwarding function）</strong>：将分组从一台路由器的入链接传送到适当的出链接。<br><img src="http://hollin.icu/CN-4-6.png" alt="4-6路由器体系结构">  </p>
<ul>
<li>输入端口。功能：<ul>
<li>执行 将一条输入的物理链路与路由器相连接的物理层 的功能。</li>
<li>执行 需要与位于入链路远端的数据链路层交互 的数据链路层功能。</li>
<li>完成查找功能。通过查询转发表决定路由器的输出端口。</li>
<li>控制分组从输入端口转发到路由选择处理器。</li>
</ul>
</li>
<li>交换结构。将输入端口和输出端口相连。</li>
<li>输出端口。</li>
<li>路由选择处理器。执行路由选择协议，维护路由选择表以及链接的链路状态信息。</li>
</ul>
<p>路由器的输入端口、输出端口和交换结构共同实现了转发功能，并且总是用硬件实现，这些转发功能有时候总称为<strong>路由器转发平面（router forwarding plane）</strong>。用硬件实现转发功能出于以下考虑：</p>
<ul>
<li>考虑10Gbps的带宽输入链路和64个字节的IP数据包，那么当下一个数据包到来之前留给路由器的时间仅有51.2ns。这个速度只能靠硬件实现。</li>
</ul>
<p>当转发平面以纳秒级运行时，路由器的控制功能以毫秒或秒的时间尺度上运行。  </p>
<p><img src="http://hollin.icu/CN-4-metaphor.png" alt="书上给出了一个很好的类比">  </p>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p><img src="http://hollin.icu/CN-4-7.png" alt="4-7输入端口处理"><br>输入端口中的查找对于路由器的运行是至关重要的。路由器使用转发表来查找输出端口，使得到达的分组将能够经过交换结构转发到该输出端口。<br>转发表是由路由选择处理器计算和更新的，但是每个输入端口实际上都有转发表的一份影子副本。有了影子副本，转发决策能在每个输入端口本地做出选择，无需调用中央路由选择处理器，避免了集中式处理的瓶颈。<br>假设转发表存在，从概念上来说查表是比较简单的。但是在具有较大输入链路的带宽的情况下，我们的查表不能用简单的线性搜索技术。所以快速查找算法是必要的。<br>一旦通过查找确定了某分组的输出端口，则改分组就能够发送进入交换结构。在一些设计中，如果来自其他端口的分组当前正在是用该交换结构，此时其他的分组可能被暂时阻塞进入交换结构。因此，一个被阻塞的分组必须要在输入端口处排队，并等待稍后被及时调度以通过交换结构。  </p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p><img src="http://hollin.icu/CN-4--8.png" alt="4-8三种交换技术">  </p>
<ul>
<li><strong>经内存交换</strong>。最简单、最早的路由器是传统的计算机，在输入端口和输出端口之间的交换功能是在CPU的直接控制下完成的。在这种情况下假设内存带宽为每秒B个分组，那么很显然总的转发吞吐量一定不会大于B/2。同时也可以注意到该方式不能同时转发两个分组，因为系统总线一次只能进行一次内存的读写。</li>
<li><strong>经总线交换</strong>。在这种情况下，输入端口经一根共享总线将分组直接传送到输入端口，不需要路由选择处理器的干预。</li>
<li><strong>经过互联网络交换</strong>。例如横纵式网络。在这种网络下可以并行转发多个分组。</li>
</ul>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p><img src="http://hollin.icu/CN-4-9.png" alt="4-9输出端口处理">  </p>
<h3 id="何时出现排队"><a href="#何时出现排队" class="headerlink" title="何时出现排队"></a>何时出现排队</h3><p>假定输入线路速度和输出线路速度式相同的，均为每秒$R_{line}$个分组，有N个输出端口和N个输入端口。定义交换结构传送速率$R_{switch}$为从输入端口到输出端口能够移动分组的速率。如果$R_{switch}$比$R_{line}$快N倍，那么在输入端口处几乎不会出现排队。<br>可是输出端口接收每个分组都需要耗费一个单位时间，在这种情况下，输入端口的内存很快就会被占满，进而造成分组被丢弃。<br><img src="http://hollin.icu/CN-4-10.png" alt="4-10输出端口排队"><br>分组在输出端口排队的后果就是需要在输出端口上配备一个<strong>分组调度程序（packet scheduler）</strong>。如果没有足够的缓存来缓存一个入分组，那么必须做出决定：丢弃新到的分组或者删除一个或多个排队的分组。<br>如果说在缓存还未满的情况下就丢弃一个分组，那么这种策略被统称为<strong>主动队列管理（Active Queue Management，AQM）算法</strong>。</p>
<p>如果交换结构不够快，那么在输入端口也有可能出现分组排队。<br><img src="http://hollin.icu/CN-4-11.png" alt="4-11输入排队HOL阻塞"></p>
<h2 id="网际协议：因特网中的转发和编址"><a href="#网际协议：因特网中的转发和编址" class="headerlink" title="网际协议：因特网中的转发和编址"></a>网际协议：因特网中的转发和编址</h2><p><img src="http://hollin.icu/CN-4-12.png" alt="4-12网络层的内部视图">  </p>
<h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="http://hollin.icu/CN-4-13.png" alt="4-13IPv4数据报格式">  </p>
<ul>
<li>版本号。四个比特规定了数据报的IP协议版本。路由器能够通过版本号确定如何解释IP数据报的剩余部分。</li>
<li>首部长度。四个比特，确定数据报中数据部分实际从哪里开始的。一般的IP数据报具有20字节的首部。</li>
<li>服务类型。用于区分不同的IP数据报。</li>
<li>数据报长度。IP数据报的总长度，以字节计。该字段有16个比特，理论上来说支持的最大长度为65535字节，但是实际上数据报很少有超过1500字节的。</li>
<li>标识、标志、片偏移。与IP分片有关，IPv6不允许在路由器上对分组分片。</li>
<li>寿命（Time-To-Live， TTL）字段用来确保数据不会永远在网络中循环。数据报每经过一个路由器，该字段的值减1。若TTL为0，则路由器必须丢弃该数据报。</li>
<li>协议。用以指示IP数据报的数据应该交付给哪个特定的运输层协议。值为6则表示交给TCP，值为17则表明交给UDP。</li>
<li>首部检验和。用于帮助路由器检测收到的IP数据报中的比特错误。每两个字节当作一个数，用反码运算对这些数求和。</li>
<li>源和目的IP地址。</li>
<li>选项。允许IP首部被拓展。</li>
<li>数据（有效荷载）。</li>
</ul>
<h4 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h4><p>一个链路层帧嫩承载的最大数据量叫<strong>最大传送单元（Maximum Transmission Unit, MTU）</strong>。<br>不是所有的链路层协议都能承载相同长度的网络层分组。一个路由器连着几条不同的链路，这些链路可能运行具有不同MTU的链路层协议。假设有一个数据报的长度大于这条链路运行协议的MTU，这时候路由器必须将IP数据报分成两片甚至多片才能成功将数据从这条链路发送出去。每个较小的数据报都称为<strong>片（fragment）</strong>。<br>IPv4的设计者感到如果在路由器中组装数据报会给协议带来相当大的复杂性并且会影响路由器性能。因此IPv4的设计者决定将数据报重新组装的工作交给端系统。<br><img src="http://hollin.icu/CN-4-14.png" alt="4-14IP分片与重新组装"><br>分片可能导致DoS攻击并且使得路由器和端系统更为复杂。  </p>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p>主机与路由器连入网络的方法：一台主机通常只有一条链路连接到网络；主机与物理链路之间的边界叫<strong>接口（interface）</strong>。<br>考虑一台路由器及其接口。路由器的任务式从链路上接收数据并从某些其他的链路转发出去，所以路由器必须拥有两条或者更多条链路与他相连。IP要求每条主机和路由器接口拥有自己的IP地址，因此，一个IP地址技术上式与一个接口相关联的，而不是与包括该接口的主机或路由器相关联的。<br>每个IP地址长度为32比特，共有$2^{32}$个可能的IP地址。这些地址一般按照所谓的<strong>点分十进制法（dotted-decimal notation）</strong>书写：每个字节用它的十进制形式书写，各字节间以.隔开。<br>如193.32.216.193的二进制法是：<br>$$11000001 00100000 11011000 00001001$$<br>所以在因特网中的每台主机的每个接口，必须有一个全球唯一的IP地址（NAT后面的接口除外）。然而，这些地址不能随意的自由选择，一个接口的IP地址的一部分需要由器连接的子网来决定。<br><img src="http://hollin.icu/CN-4-15.png" alt="4-15接口地址和子网"><br>如图4-15，一台路由器用于互联7台主机。左上角的三台主机最左侧24比特是相同的。这四个接口通过一个并不包含路由器的网络互联起来。<br>用IP的术语来说，互联这三个主机接口与一个路由器接口的网络形成了一个<strong>子网（subnet）</strong>。IP编址为这个子网分配了一个地址：223.1.1.0/24，其中/24的记法称为<strong>子网掩码（network mask）</strong>，指示了32比特中的最左侧24位定义了子网地址。因此子网223.1.1.0/24是由三台主机接口和一个路由器接口组成，任何其他要连接到223.1.1.0/24网络的主机都要求其地址具有223.1.1.xxx的形式。<br><img src="http://hollin.icu/CN-4-17.png" alt="4-17三条路由器互联六个子网"><br>一个子网IP定义不局限于连接堕胎主机到一个路由器接口的以太网段。在4-17中，三团云分别是三个子网。同时三条点对点链路是三个不同的子网。<br><strong>为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫做一个子网（subnet）。</strong><br>因特网的地址分配策略被称为<strong>无类别域间路由（Classless Interdomain Routing, CIDR）</strong>。<br>形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的<strong>前缀（prefix）</strong>。一个组织通常被分配一块连续的地址。<br>一个地址的剩余32-x比特可认为u是用于区分该分组内部设备的。其中所有设备具有相同的网络前缀。当该组织内部的路由器转发分时候，才会考虑这些比特。这些较低的比特可能具有另外的子网结构。<br>在CIDR被采用之前，IP地址的网络部分被限制子为长度为8、16或24比特。这是一种称为<strong>分类编址（classful addressing）</strong>的编址方式。这是因为具有8、16和24比特子网地址的子网分别被称为A、B和C类网络。这种要求使得在支持数量迅速增长的具有小规模或中规模子网的组织方面出现了问题。一个C类的子网仅能容纳$2^8-2=254$台主机（其中有两个预留用于特殊用途），这对于许多组织来说太小了。而一个B类网络多达65535台主机又太多了。<br>当一台主机发出一个目的地址为255.255.255.255的数据报时，该报文会交付给同一个网络中的所有主机。楼尤其也会又选择地向临近的子网转发该报文。</p>
<h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><p>为了获取一块IP地址用于一个住址的网络，某网络管理员也许首先会于他的ISP联系。该ISP可能会从已分给他的更大地址块中提供一些地址。IP地址由<strong>因特网名字和编号分配机构（Internet Corporation for Assigned Names and Numbers, ICANN）</strong>管理。</p>
<h4 id="获取主机地址：动态主机配置协议DHCP"><a href="#获取主机地址：动态主机配置协议DHCP" class="headerlink" title="获取主机地址：动态主机配置协议DHCP"></a>获取主机地址：动态主机配置协议DHCP</h4><p>当我们获取了一块IP地址过后，我们就可以给我们的主机和路由器接口逐个分配IP地址。显然，我们可以手动配置，但是更多的是通过<strong>动态主机配置协议（Dynamic Host Configuration, DHCP）</strong>来进行的。<br>网络管理员能够配置DHCP，使得某给定主机每次于网络连接时能够得到一个相同的IP地址，或者某主机将分配一个临时的<strong>IP地址（temporary IP address）</strong>，该地址每次连入网络时可能是不同的。<br>由于DHCP具有能够将主机接入一个网络的网络相关方面的自动能力，又被称为<strong>即插即用协议（plug-and-play protocol）</strong>。非常省事。<br>DHCP是一个客户-服务器协议。如果在某子网中没有服务器，则需要一个DHCP中继代理（通常是一台路由器），这个代理直到该网络的DHCP服务器的地址。<br><img src="http://hollin.icu/CN-4-21.png" alt="4-21客户-服务器交互"><br>对于一台新到达的主机而言，DHCP协议是四个步骤的过程：</p>
<ul>
<li><strong>DHCP服务器发现</strong>。一台新到的主机首要任务事发现一个要与其交互的DHCP服务器。这可以通过使用一个<strong>DHCP发现报文（DHCP discover message）</strong>来完成。客户在UDP分株中向端口67发送在发现报文。DHCP客户生成包含DHCP发现报文的IP数据报，使用广播的目的地址255.255.255.255并使用本主机的源地址0.0.0.0。DHCP客户将该IP数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的子网。</li>
<li>DHCP服务器提供。DHCP服务器收到一个DHCP发现报文时，用一个<strong>DHCP提供报文（DHCP offer message）</strong>向客户做出响应，使用IP广播地址。</li>
<li>DHCP请求。新到达的客户从一个或者多个服务器中选择一个，并向选中的服务器提供一个<strong>DHCP请求报文（DHCP request message）</strong>进行响应，回显配置参数。</li>
<li>DHCP ACK。服务器用DHCP（DHCP ACK message）对DHCP请求报文进行响应，证实所要求的参数。</li>
</ul>
<h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>每个IP使能的设备都需要一个IP地址。在这种情况下，如果说家里有很多台设备需要同时联网，在ISP划分给家庭的IP地址不够的情况下该怎么办呢？有一个简单的方法可以解决这个情况：<strong>网络地址转换（Network Address Translation, NAT）</strong>。<br><img src="http://hollin.icu/CN-4-22.png" alt="4-22网络地址转换"><br>所谓的网络地址转换，就是让路由器对于外部设备来说不像一台路由器，反而它的行为像是一个具有单一IP地址的单一设备。<br>如图4-22，在家庭内部的四个接口都具有相同的网络地址：10.0.0.0/24。地址空间10.0.0.0/8时在RFC 1918中保留的三部分IP地址空间之一，这些地址用于家庭网络等专用网络或具有专用地址的<strong>地域（realm）</strong>。地域的意思是地址对该网络中的设备有意义的网络。出了这个特定范围就没有意义。在这种情况下，所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址138.76.29.7。NAT使路由器隐藏了家庭网络的细节。<br>NAT通过NAT转换表将LAN端的数据报进行修改，生成一个新的源端口号并且将IP地址修改成138.76.29.7。这样一来，他的六万多个端口就可以对应六万多个专用IP。<br>NAT在近年来被广泛使用，然而它也被IETF团队的纯化论者反对。主要出于几个原因：</p>
<ul>
<li>端口号是用于进程编址的，而不是用于主机编址的。</li>
<li>路由器应该处理高达第三层的分组。</li>
<li>NAT违反了端到端协议（主机之间应该直接对话，结点不应该修改IP地址和端口号）。</li>
<li>使用IPv6来解决IP短缺的问题，而不应该使用NAT。</li>
</ul>
<p>NAT的另一个问题是它很影响P2P应用程序。因为P2P应用程序需要两台主机直接相连。</p>
<h4 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h4><p>NAT穿越越来越多由即插即用的UPnP提供。</p>
<h4 id="因特网控制报文协议ICMP"><a href="#因特网控制报文协议ICMP" class="headerlink" title="因特网控制报文协议ICMP"></a>因特网控制报文协议ICMP</h4><p>ICMP被主机和路由器用来彼此沟通网络层的信息。最经典的用贴图是差错报告。<br>ICMP通常被认为是IP的一部分，但是从实际功能上来说它是处于IP之上的，因为它的报文是承载在IP分组中的。<br>ICMP报文有一个类型字段和一个编码字段。<br><img src="http://hollin.icu/CN-4-23.png" alt="4-23ICMP报文类型">  </p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><p><img src="http://hollin.icu/CN-4-24.png" alt="4-24IPv6数据报格式"><br>IPv6相比较于IPv4的变化有：</p>
<ul>
<li>扩大的地址容量。IPv6中将地址长度从32比特增加到了128比特。</li>
<li>简化高效的40字节首部。</li>
<li><strong>流（flow）</strong>标签与优先级。流字段可用于给属于特殊流的分组加上标签，这些流是发送方要求进行特殊处理的流。可以是音频或者视频的传输。优先级…</li>
</ul>
<p>IPv6中定义的字段有：</p>
<ul>
<li>版本。显然当该字段中的值为6时指示当前使用的IP版本为IPv6。</li>
<li>流量类型。和IPv4中的TOS类似。</li>
<li>流标签。</li>
<li>有效荷载长度。16比特，给出了IPv6数据报中跟在定长的40字节首部后面的<strong>字节</strong>长度。</li>
<li>下一个首部。替代了IPv4中的协议类型以及选项。</li>
<li>跳限制。</li>
<li>源地址和目的地址。</li>
<li>数据。</li>
</ul>
<p>和IPv6相比，IPv4中有几个字段已经不复存在：</p>
<ul>
<li>分片/重新组装。</li>
<li>首部和检验。在IPv4中，TTL字段每经过一个路由器都会被减一，路由器就需要重新计算数据报的首部检验和，相当耗时。</li>
<li>选项。</li>
</ul>
<h4 id="从IPv4到IPv6的迁移"><a href="#从IPv4到IPv6的迁移" class="headerlink" title="从IPv4到IPv6的迁移"></a>从IPv4到IPv6的迁移</h4><p>IPv6可以使得系统做成向后兼容，但是IPv4的系统不能够处理IPv6的数据报。那么从IPv4迁移到IPv6可能采用以下几种方法。</p>
<ol>
<li>选定一个标志日，从这个标志日的某个时间开始，因特网所有的机器都关机并从IPv4升级到IPv6。技术迁移。</li>
<li><strong>双栈（dual-stack）</strong>方法。路由器同时拥有的处理两种版本数据报的能力。双栈的一种方法叫<strong>建隧道（tunneling）</strong>的方法。就是将IPv6的数据报的外面再套上IPv4的首部，那么IPv4的路由器以为自己处理的是一个IPv4的数据报。</li>
</ol>
<h3 id="涉足IP安全性"><a href="#涉足IP安全性" class="headerlink" title="涉足IP安全性"></a>涉足IP安全性</h3><p>现在提出了各种安全性服务的新型网络层协议。其中之一时IPsec，这是一种非常流行的安全网络层协议，在VPN中的到了广泛部署。<br>IPsec被设计为IPv4和IPv6向后兼容。使用IPsec也很简单，不需要改动任何路由器或者主机中的协议栈。两台主机之间同时使用IPsec就可以安全通信。<br>一个使用IPsec的具体例子：两台主机首先在他们之间创建一个IPsec会话。在两台主机之间的任何TCP和UDP报文段都将享受IPsec提供的安全性服务。运输层向IPsec传递一个报文段，IPsec加密这个报文段并在一个普通的IP数据报中封装得到的有效荷载。接收方的IPsec负责解密报文段并且传送给运输层。<br>IPsec提供的服务有：</p>
<ul>
<li>密码技术也顶。</li>
<li>IP数据报有效荷载的加密。</li>
<li>数据完整性。</li>
<li>初始鉴别。</li>
</ul>
<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>主机通常直接与一台路由器相连，该路由器称为该主机的<strong>默认路由器（default router）</strong>，也称为<strong>第一跳路由器（first-hop router）</strong>。每当主机发送一个分组时，分组被传送给他的默认路由器，将这个路由器称为<strong>源路由器（source router）</strong>，把目的主机的路由器称为<strong>目的路由器（destination router）</strong>。<br>路由选择算法的目的：给定一组路由器以及连接路由器的链路，路由选择算法苏泽找到一条从源路由器到目的路由器的“好”路径。实际上路由问题转化成了图的问题。<br>在这种情况下，路由算法可以具体分为两种：</p>
<ul>
<li><strong>全局式的路由选择算法（global routing algorithm）</strong>用完整的、全局性的网络知识计算从源到目的地之间的最低费用路径。在这种情况下，网络中所有的路由器以及链路的状态都需要在开始时输入系统。具有全局状态信息的算法被称为<strong>链路状态（Link State，LS）算法</strong>。</li>
<li>分散式路由选择算法（decentralized routing algorithm）以迭代、分布式的方式计算出最低费用路径。没有结点拥有关于所有网络链路费用的完整信息。一个结点逐渐计算出到达某个目的结点的最低费用。这种算法被称为一个<strong>距离向量（Distance-Vector，DV）算法</strong>。</li>
</ul>
<p>或者分为<strong>静态路由选择算法</strong>或者<strong>动态路由选择算法</strong>。</p>
<ul>
<li>静态路由选择算法需要人工配置转发表。</li>
<li>动态路由选择算法能够根据网络流量负载或者拓扑的变化而选择路径。</li>
</ul>
<p>或者分为负载敏感算法（load-sensitive algorithm）或者负载迟钝（load-insensitive algorithm）算法。</p>
<h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><p>在链路状态算法中，网络拓扑和所有的链路费用都是已知的。那么每个链路的特征和费用都需要作为输入输入到系统中。在实践中由<strong>链路状态广播（link state broadcast）</strong>完成。通常可以使用Dijkstra算法完成。</p>
<h3 id="距离向量路由选择-待详学"><a href="#距离向量路由选择-待详学" class="headerlink" title="距离向量路由选择-待详学"></a>距离向量路由选择-待详学</h3><p>距离向量（Distance-Vector，DV）算法是一种迭代的、异步的和分布式的算法。<br>Bellman-Ford方程。</p>
<h3 id="层次路由选择-跳过"><a href="#层次路由选择-跳过" class="headerlink" title="层次路由选择-跳过"></a>层次路由选择-跳过</h3><p>在LS和DV的算法研究中，我们将网络看做成一个互联路由器的集合。在实践中，该模型和这种一组执行同样路由选择算法的同质路由器集合的观点有一点简单化，至少有以下两个重要原因：</p>
<ul>
<li>规模。随着路由器的数目变得很大，涉及路由选择信息计算、存储及通信的开销将高得不可实现。</li>
<li>管理自洽。如某公司要求按照自己的意愿运行路由器。</li>
</ul>
<p>这两个问题都可以通过将路由器组织进<strong>自洽系统（Autonomous System，AS）</strong>来解决。每个AS由一组通常出来相同管理控制下的路由器组成。在相同AS下的路由器全部都运行同样的路由选择算法。在一个自洽系统内运行的路由选择算法叫做<strong>自洽系统内部路由选择协议（intra-autonomous system routing protocol）</strong>。负责在本AS之外的目的地转发分组的路由器被称为<strong>网关路由器（gateawy router）</strong>。<br>自然而言的，两个相邻的AS之间的路由选择协议称为自洽系统间的路由选择协议（inter-autonomous system routing protocol）。两个相邻的AS之间必须运行相同的路由选择协议。事实上，因特网间所有的AS中都运行者相同的路由选择协议BGP4。  </p>
<h2 id="因特网中的路由选择协议"><a href="#因特网中的路由选择协议" class="headerlink" title="因特网中的路由选择协议"></a>因特网中的路由选择协议</h2><h4 id="因特网中自洽系统内部的路由选择：RIP"><a href="#因特网中自洽系统内部的路由选择：RIP" class="headerlink" title="因特网中自洽系统内部的路由选择：RIP"></a>因特网中自洽系统内部的路由选择：RIP</h4><p>AS内部路由选择协议又称为<strong>内部网关协议（interior gateway protocol）</strong>。历史上有两个路由选择协议曾被广泛用于因特网上自洽系统内的路由选择：<strong>路由选择信息协议（Routing Information Protocol, RIP）</strong>与<strong>开放最短路优先（Open Shortest Path First，OSPF）</strong>。<br>RIP是最早的AS内部因特网路由选择协议之一，并且目前仍在广泛使用。他是一种距离向量协议。费用被定义在路由对之间，从源路由器到目的子网的最短路径所经过的子网数量被称为<strong>跳</strong>。<br>路由选择更新的信息通过一种<strong>RIP响应报文（RIP response message）</strong>进行交换，又被称为<strong>RIP通告（RIP advertisement）</strong>。</p>
<h3 id="因特网中自洽系统内部的路由选择：OSPF"><a href="#因特网中自洽系统内部的路由选择：OSPF" class="headerlink" title="因特网中自洽系统内部的路由选择：OSPF"></a>因特网中自洽系统内部的路由选择：OSPF</h3><p>OSPF是一个使用了洪泛链路状态信息的链路状态协议和一个Dijkstra最低费用路径算法。  </p>
<h3 id="自洽系统间的路由选择：BGP"><a href="#自洽系统间的路由选择：BGP" class="headerlink" title="自洽系统间的路由选择：BGP"></a>自洽系统间的路由选择：BGP</h3><p><strong>边界网关协议（Border Gateway Protocol，BGP）</strong>为每个AS提供了进行以下工作的手段：</p>
<ol>
<li>从相邻的AS处获得子网可达性信息。</li>
<li>向本AS内部的说有路由器传播这些可达性信息。</li>
<li>基于可达性信息和AS策略，决定到达子网的“好”路由。</li>
</ol>
<h4 id="BGP基础——待深入"><a href="#BGP基础——待深入" class="headerlink" title="BGP基础——待深入"></a>BGP基础——待深入</h4><p>BGP极其复杂但是绝对是因特网中之绝对至关重要的协议。  </p>
<h2 id="广播和多播路由选择"><a href="#广播和多播路由选择" class="headerlink" title="广播和多播路由选择"></a>广播和多播路由选择</h2><h3 id="广播路由选择算法"><a href="#广播路由选择算法" class="headerlink" title="广播路由选择算法"></a>广播路由选择算法</h3><p>最简单的方式是<strong>N次单播（N-way-unicast）</strong>：直接准备N个副本，修改一下目的地并向N个目的地传输这N个分组。但是这个方法的缺点也很明显：</p>
<ul>
<li>效率低。源节点需要发送N个分组出去。</li>
<li>接收方都需要被发送方已知。</li>
</ul>
<p>在这种情况下，网络结点本身在分组复制、转发和广播是比较好的。</p>
<h4 id="无控制洪泛"><a href="#无控制洪泛" class="headerlink" title="无控制洪泛"></a>无控制洪泛</h4><p>实现广播最简单的技术是<strong>洪泛（flooding）</strong>方法，他要求源节点向他的所有邻居发送分组的副本。但如果网络拓扑中有一个圈，就会导致每个广播的一个分组将无休止的循环。当一个结点与两个以上的结点连接时，将会导致网络中生成大量的广播分组，产生<strong>广播风暴（broadcast storm）</strong>。</p>
<h4 id="受控洪范"><a href="#受控洪范" class="headerlink" title="受控洪范"></a>受控洪范</h4><p>避免广播风暴的关键是每个结点明智选择何时洪泛分组，何时不洪泛分组。有以下几种方式：</p>
<ul>
<li><strong>序号控制洪泛（sequence-number-controlled flooding）</strong>，源结点将其地址以及<strong>广播序号（broadcast sequence number）</strong>放入广播分组，再向它的所有邻居发送该分组。每个结点维护它已经收到的、复制的和转发的源地址和每个广播分组的序号列表。当结点接收到一个广播分组时，首先检查分组是否再列表中，如果在，丢弃该发呢组，如果不在就复制并转发。</li>
<li><strong>反向路径转发（Reverse Path Forwarding，RPF）</strong>。当一台路由器收到具有给定源地址的广播分组时，仅当该分组到达的链路正好是位于它自己的返回其源的最短单波路径上，才向其他所有出链路传输报文；否则就丢弃这个报文。（源地址在转发的过程中不会变）</li>
</ul>
<h4 id="生成树广播"><a href="#生成树广播" class="headerlink" title="生成树广播"></a>生成树广播</h4><p>找一个最小生成树然后发送广播分组，广播分组只能生成树的路径中进行转发。</p>
<h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p>广播是将分组交付给网络中的所有结点，多播分组仅被交付给网络结点中的一个子集。在实际中，一些新兴的网络应用要求将分组从一个或多个发送方交付给一组接收方。<br>在多播通信中面临两个问题：</p>
<ul>
<li>怎样标识多播分组的接收方。</li>
<li>怎样为发送到这些接收方的分组编址。</li>
</ul>
<p>显然，标识所有的多播分组接收方的IP地址是行不通的。因此多播数据使用<strong>间接地址（address indirection）</strong>来编址。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/02/02/course/c++/C%E8%AF%AD%E8%A8%80%E8%80%83%E7%82%B9%E5%BD%92%E7%BA%B3/" rel="prev" title="C语言考点归纳">
                  <i class="fa fa-chevron-left"></i> C语言考点归纳
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/02/16/computer-networking/computer-networking-chapter5/" rel="next" title="计算机网络第五章学习笔记">
                  计算机网络第五章学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hollin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>






  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  





  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '8a7b02eb5d0c2de5e0d0',
      clientSecret: '419871631462c7a557d7d2f166733a67dce88db',
      repo        : 'Hooollin.github.io',
      owner       : 'Hooollin',
      admin       : ['Hooollin'],
      id          : '75b5f0fbbb48339e7c81cf545d08f006',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
